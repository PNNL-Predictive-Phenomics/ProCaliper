{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"home","text":""},{"location":"#procaliper","title":"procaliper","text":"<p>A tool for fetching and organizing protein data in order to perform structure calculations.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install from PyPI:</p> <pre><code>pip install procaliper\n</code></pre>"},{"location":"#extras","title":"extras","text":"<p>During installation, <code>procaliper</code> will also install <code>openbabel-wheel</code>. If you require specialized features of <code>openbabel</code> that are not available in this precompiled version, please run <code>pip uninstall openbabel-wheel</code> after <code>procaliper</code> is installed and provide your own version of the <code>openbabel</code> python library.</p> <p>Optional feature dependencies can be installed as follows:</p> <pre><code>pip install procaliper[nglview,pka]\n</code></pre> <p>The <code>nglview</code> extra provides the ability to visualize protein structures in a graphical notebook environment.</p> <p>The <code>pka</code> extra provides additional methods for computing disassociation constants (typically denoted \\(pK_a\\)). Note that installing this extra requires obtaining  a <code>DelPhi</code> license. Furthermore, these additional methods require an older version of <code>numpy</code> (version <code>1.26.4</code>) and <code>python</code> version between <code>3.9</code> and <code>3.11</code> to properly function. If the <code>pka</code> extra is not installed, <code>procaliper</code> will use propka for \\(pK_a\\) calculation.</p>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>A basic example is provided here. See the examples folder for further examples.</p> <pre><code>import procaliper as pc\n\n# Read in or download protein structure\nprotein = pc.Protein.from_uniprot_id(\"A0A0B4J2F0\") # create a protein object from UniProt metadata using a UniProt ID\n# alternatively, you can read in a protein from a UniProt Table using `Protein.from_uniprot_row`\n\n# Download &amp; save protein structure from AlphaFold\nprotein.fetch_pdb(save_path=\"A0A0B4J2F0.pdb\") \n# Alternatively, `protein.register_local_pdb(file)` can be used to specify a previously downloaded pdb file\n\n# Compute structure features\nsasa = protein.get_sasa() # compute site-level SASA values\ncharge = protein.get_charge() # compute site-level charges\ntitr = protein.get_titration() # compute site-level titration (pKa) data\n# The results from the above calculations are autmatically stored in the `protein` object.\n\n# Get a table of site-level data\nsite_data = protein.unravel_sites() # returns a dictionary of lists; readable, e.g., by `pandas`\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome!</p> <p>See Contributing for detailed instructions.</p>"},{"location":"#license","title":"License","text":"<p>This code is released under GPL v3. See our License for detailed information.</p> <p>By default, <code>procaliper</code> does not have any dependencies that are not freely licensed. However, additional features can be installed that rely on restricted software. That is, please note that some optional dependencies are not FOSS. Specifically, the <code>pka</code> extra requires a <code>DelPhi</code> license. We encourage caution when using software that is not free and open source, especially for contributions to the scientific literature.</p>"},{"location":"#credits","title":"Credits","text":"<p>This work is supported by the Predictive Phenomics Initiative at Pacific Northwest National Laboratory.</p>"},{"location":"api/","title":"modules","text":"<p>Top-level package for procaliper.</p>"},{"location":"api/#procaliper.Protein","title":"<code>Protein</code>","text":"Source code in <code>procaliper/_protein.py</code> <pre><code>class Protein:\n    UNIPROT_SITE_PATTERNS = {\n        \"Active site\": \"ACT_SITE\",\n        \"Binding site\": \"BINDING\",\n        \"DNA binding\": \"DNA_BIND\",\n        \"Disulfide bond\": \"DISULFID\",\n        \"Beta strand\": \"STRAND\",\n        \"Helix\": \"HELIX\",\n        \"Turn\": \"TURN\",\n    }\n\n    UNIPROT_SITE_PATTERNS_RECTIFIED = {\n        \"active\": \"ACT_SITE\",\n        \"binding\": \"BINDING\",\n        \"dna_binding\": \"DNA_BIND\",\n        \"disulfide_bond\": \"DISULFID\",\n        \"beta_strand\": \"STRAND\",\n        \"helix\": \"HELIX\",\n        \"turn\": \"TURN\",\n    }\n\n    UNIPROT_API_DEFAULT_FIELDS = [\n        \"id\",\n        \"reviewed\",\n        \"protein_name\",\n        \"gene_names\",\n        \"organism_name\",\n        \"length\",\n        \"sequence\",\n        \"ft_act_site\",\n        \"ft_binding\",\n        \"ft_dna_bind\",\n        \"ft_disulfid\",\n        \"ft_strand\",\n        \"ft_helix\",\n        \"ft_turn\",\n    ]\n\n    def __init__(self) -&gt; None:\n        self.data: dict[str, Any] = {}\n        self.pdb_location_relative: str | None = None\n        self.pdb_location_absolute: str | None = None\n\n        self.site_annotations: SiteAnnotations = SiteAnnotations(\"\")\n        self.custom_site_data: CustomSiteData = CustomSiteData([], {})\n\n        self.confidence_data: list[float] | None = None\n        self.sasa_data: structure.sasa.SASAData | None = None\n        self.charge_data: structure.charge.ChargeData | None = None\n        self.cysteine_data: structure.cysteine_data.CysteineData | None = None\n        self.titration_data: structure.titration.TitrationData | None = None\n        pass\n\n    def _rectify_label(self, label: str) -&gt; str:\n        new_label = label.replace(\" \", \"_\").lower()\n        new_label = new_label.removesuffix(\"_site_sites\")\n        new_label = new_label.removesuffix(\"_site\")\n        return new_label\n\n    def _rectify_data_labels(self) -&gt; None:\n        \"\"\"\n        Standardize the features names in self.data\n\n        Replaces all spaces with underscores and lowercases the keys, and then\n        replaces all instances of \"_site_sites\" with \"_sites\"\n        \"\"\"\n        for k in list(self.data.keys()):\n            new_key = self._rectify_label(k)\n            self.data[new_key] = self.data.pop(k)\n\n    @classmethod\n    def from_uniprot_row(cls, row: dict[str, Any]) -&gt; Protein:\n        \"\"\"Create a new Protein object from a row from a Uniprot table\n\n        Args:\n            row (dict[str, Any]): Contains the data from the Uniprot table. Must\n                have \"Sequence\" or \"sequence\" as a key.\n\n        Raises:\n            ValueError: If \"Sequence\" or \"sequence\" is not found in the row.\n\n        Returns:\n            Protein: A processed and standardized protein object.\n        \"\"\"\n        p = cls()\n        if \"Sequence\" in row:\n            p.data[\"sequence\"] = row[\"Sequence\"]\n        elif \"sequence\" in row:\n            p.data[\"sequence\"] = row[\"sequence\"]\n        else:\n            raise ValueError(f\"Sequence not found in row: {row}\")\n        p.custom_site_data.add_residue_numbers(len(p.data[\"sequence\"]))\n        p.site_annotations = SiteAnnotations(p.data[\"sequence\"])\n        for key, value in row.items():\n            key = p._rectify_label(key)\n            if key in cls.UNIPROT_SITE_PATTERNS_RECTIFIED:\n                uniprot_description_id = cls.UNIPROT_SITE_PATTERNS_RECTIFIED[key]\n                p.site_annotations.extract_annotation(uniprot_description_id, value)\n            elif key in cls.UNIPROT_SITE_PATTERNS:\n                uniprot_description_id = cls.UNIPROT_SITE_PATTERNS[key]\n                p.site_annotations.extract_annotation(uniprot_description_id, value)\n            else:\n                if value != value:\n                    value = \"\"\n                p.data[key] = value\n        return p\n\n    @classmethod\n    def from_uniprot_id(\n        cls,\n        uniprot_id: str,\n        fields: list[str] | None = None,\n        from_db: str = \"UniProtKB_AC-ID\",\n        to_db: str = \"UniProtKB-Swiss-Prot\",\n    ) -&gt; Protein:\n        \"\"\"Create a new Protein object from a Uniprot ID (fetches with Uniprot API)\n\n        Args:\n            uniprot_id (str): The Uniprot ID of the protein.\n            fields (list[str] | None, optional): The fields to retrieve from\n                Uniprot. If `None`, `Protein.UNIPROT_API_DEFAULT_FIELDS` is used.\n            from_db (str, optional): The database to retrieve the ID from.\n                Defaults to \"UniProtKB_AC-ID\".\n            to_db (str, optional): The database to map to.\n                Defaults to \"UniProtKB-Swiss-Prot\".\n\n        Raises:\n            ValueError: If we cannot retrieve the Uniprot ID.\n\n        Returns:\n            Protein: A processed and standardized protein object.\n        \"\"\"\n\n        if not fields:\n            fields = cls.UNIPROT_API_DEFAULT_FIELDS\n\n        mapper = ProtMapper()\n\n        result, error = mapper.get(\n            ids=[uniprot_id], fields=fields, from_db=from_db, to_db=to_db\n        )\n        if error:\n            raise ValueError(f\"Uniprot id not retrieved: {error}\")\n        result.rename(columns={\"From\": \"entry\"}, inplace=True)\n        if \"Length\" in result.columns:\n            result[\"Length\"] = pd.to_numeric(result[\"Length\"])\n        return cls.from_uniprot_row(result.iloc[0].to_dict())\n\n    @classmethod\n    def list_from_uniprot_ids(\n        cls,\n        uniprot_ids: list[str],\n        fields: list[str] | None = None,\n        from_db: str = \"UniProtKB_AC-ID\",\n        to_db: str = \"UniProtKB-Swiss-Prot\",\n    ) -&gt; list[Protein]:\n        \"\"\"Create a list of Protein objects from a list of Uniprot IDs (fetches with Uniprot API)\n\n        Args:\n            uniprot_ids (list[str]): The Uniprot IDs of the proteins.\n            fields (list[str] | None, optional): The fields to retrieve from\n                Uniprot. If `None`, `Protein.UNIPROT_API_DEFAULT_FIELDS` is used.\n            from_db (str, optional): The database to retrieve the IDs from.\n                Defaults to \"UniProtKB_AC-ID\".\n            to_db (str, optional): The database to map to.\n                Defaults to \"UniProtKB-Swiss-Prot\".\n\n        Raises:\n            ValueError: If we cannot retrieve the Uniprot IDs.\n\n        Returns:\n            list[Protein]: A list of processed and standardized protein objects.\n        \"\"\"\n        if not fields:\n            fields = cls.UNIPROT_API_DEFAULT_FIELDS\n\n        mapper = ProtMapper()\n\n        result, error = mapper.get(\n            ids=uniprot_ids, fields=fields, from_db=from_db, to_db=to_db\n        )\n        if error:\n            raise ValueError(f\"Uniprot id not retrieved: {error}\")\n        result.rename(columns={\"From\": \"entry\"}, inplace=True)\n\n        if \"Length\" in result.columns:\n            result[\"Length\"] = pd.to_numeric(result[\"Length\"])\n        return [cls.from_uniprot_row(row.to_dict()) for _, row in result.iterrows()]\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Protein):\n            return False\n        return (\n            self.data == other.data\n            and self.sasa_data == other.sasa_data\n            and self.charge_data == other.charge_data\n            and self.cysteine_data == other.cysteine_data\n        )\n\n    def residue_data_frame(self) -&gt; pd.DataFrame:\n        d = dict(\n            chain(\n                self.get_charge().items(),\n                self.get_sasa().items(),\n                self.get_cysteine_data().items(),\n                self.get_titration().items(),\n            )\n        )\n        d[\"pLDDT\"] = self.get_confidence()\n\n        return pd.DataFrame(d)\n\n    def get_confidence(self) -&gt; list[float]:\n        \"\"\"Fetches precomputed confidence data from pdb file.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `confidence_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            list[float]: A list of confidence values for each residue.\n        \"\"\"\n        if self.confidence_data:\n            return self.confidence_data\n\n        if self.pdb_location_absolute:\n            self.confidence_data = structure.confidence.residue_pLDDT(\n                self.pdb_location_absolute,\n            )\n            return self.confidence_data\n        else:\n            raise ValueError(\n                \"Confidence data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_sasa(self) -&gt; structure.sasa.SASAData:\n        \"\"\"Fetches precomputed SASA data for the protein, or computes it.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `sasa_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            structure.sasa.SASAData: A :class:`protein_structure.sasa.SASAData`\n                object containing the SASA values for residues and atoms.\n        \"\"\"\n        if self.sasa_data:\n            return self.sasa_data\n\n        if self.pdb_location_absolute:\n            self.sasa_data = structure.sasa.calculate_sasa(\n                self.pdb_location_absolute,\n            )\n            return self.sasa_data\n        else:\n            raise ValueError(\n                \"SASA data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_charge(self, method: str = \"gasteiger\") -&gt; structure.charge.ChargeData:\n        \"\"\"Fetches precomputed charge data for the protein, or computes it.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Args:\n            method (str, optional): The method used for the charge calculation.\n                Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to\n                'gasteiger'. For a full list reference\n                https://open-babel.readthedocs.io/en/latest/Charges/charges.html\n\n        Raises:\n            ValueError: If `charge_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            structure.charge.ChargeData: A :class:`protein_structure.charge.ChargeData`\n                object containing the charge values for residues and atoms.\n        \"\"\"\n        if self.charge_data:\n            if self.charge_data[\"charge_method\"]:\n                if self.charge_data[\"charge_method\"][0] == method:\n                    return self.charge_data\n\n        if self.pdb_location_absolute:\n            self.charge_data = structure.charge.calculate_charge(\n                self.pdb_location_absolute,\n                method=method,\n            )\n\n            self.last_charge_method = method\n\n            return self.charge_data\n        else:\n            raise ValueError(\n                \"Charge data for specified method not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_cysteine_data(self) -&gt; structure.cysteine_data.CysteineData:\n        \"\"\"Fetches precomputed size data for the protein, or computes it.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `cysteine_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            structure.size.CysteineData: A :class:`protein_structure.size.CysteineData`\n                object containing the size values for cystein sites.\n        \"\"\"\n        if self.cysteine_data:\n            return self.cysteine_data\n\n        if self.pdb_location_absolute:\n            self.cysteine_data = structure.cysteine_data.calculate_cysteine_data(\n                self.pdb_location_absolute,\n            )\n            return self.cysteine_data\n        else:\n            raise ValueError(\n                \"Size data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_titration(self) -&gt; structure.titration.TitrationData:\n        \"\"\"Runs the default titration calculation for the protein.\n\n        Equivalent to running `self.get_titration_from_propka`.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `titration_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            structure.titration.TitrationData: A\n                :class:`protein_structure.titration.TitrationData` object containing\n                the titration values for residues.\n        \"\"\"\n        return self.get_titration_from_propka()\n\n    def get_titration_from_propka(self) -&gt; structure.titration.TitrationData:\n        \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n        Uses :func:`protein_structure.titration.calculate_titration_propka` if\n        `self.titration_data` is not already stored.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `titration_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            structure.titration.TitrationData: A\n                :class:`protein_structure.titration.TitrationData` object containing\n                the titration values for residues.\"\"\"\n        if self.titration_data:\n            return self.titration_data\n\n        if self.pdb_location_absolute:\n            self.titration_data = structure.titration.calculate_titration_propka(\n                self.pdb_location_absolute,\n            )\n            return self.titration_data\n        else:\n            raise ValueError(\n                \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_titration_from_pypka(self) -&gt; structure.titration.TitrationData:\n        \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n        Uses :func:`protein_structure.titration.calculate_titration_pypka` if\n        `self.titration_data` is not already stored. Requires pypka to be\n        installed, which has dependencies that are not FOSS. Please be sure to\n        verify that you are legally allowed to use pypka.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `titration_data` is not already stored and\n                `pdb_location_absolute` is not set. ImportError: If pypka is not\n                installed.\n\n        Returns:\n            structure.titration.TitrationData: A\n                :class:`protein_structure.titration.TitrationData` object containing\n                the titration values forresidues.\"\"\"\n\n        if self.titration_data:\n            return self.titration_data\n\n        if self.pdb_location_absolute:\n            self.titration_data = structure.titration.calculate_titration_pypka(\n                self.pdb_location_absolute,\n            )\n            return self.titration_data\n        else:\n            raise ValueError(\n                \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_titration_from_pkai(self) -&gt; structure.titration.TitrationData:\n        \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n        Uses :func:`protein_structure.titration.calculate_titration_pkai` if\n        `self.titration_data` is not already stored. Requires pkai to be\n        installed. Note that this method is a deep-learning model, not a\n        physics-based calculation.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `titration_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns: structure.titration.TitrationData: A\n            :class:`protein_structure.titration.TitrationData` object containing\n                the titration values for residues.\"\"\"\n        if self.titration_data:\n            return self.titration_data\n\n        if self.pdb_location_absolute:\n            self.titration_data = structure.titration.calculate_titration_pkai(\n                self.pdb_location_absolute,\n            )\n            return self.titration_data\n        else:\n            raise ValueError(\n                \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def add_custom_site_data_column(\n        self, key: str, site_data: list[Any], overwrite: bool = False\n    ) -&gt; None:\n        if not self.custom_site_data.residue_number:\n            self.custom_site_data.add_residue_numbers(len(self.data[\"sequence\"]))\n        self.custom_site_data.add_site_data(key, site_data, overwrite=overwrite)\n\n    def unravel_sites(\n        self,\n        selected_aas: None | set[AminoAcidLetter] = None,\n        selected_keys: None | set[str] = None,\n    ) -&gt; dict[str, list[Any]]:\n        \"\"\"Split the protein into individual sites, recording values for each.\n\n        Args:\n            selected_aas: A set of amino acids letters to include in the output.\n                If `None` (default), all amino acids will be included.\n            selected_keys: A set of keys belonging to this `Protein` object's\n                `data` dictionary to include in the output. If `None` (default),\n                all keys are used.\n\n        Returns:\n            dict[str, list[Any]]: A dictionary mapping keys to lists of values.\n                Each list is a parallel array of the same length as the protein\n                sequence (after filtering out non-selected amino acids).\"\"\"\n        tbl = self.site_annotations.table() | self.custom_site_data.table()\n        if selected_keys is None:\n            selected_keys = (set(tbl.keys()) | set(self.data.keys())) - {\"sequence\"}\n        tbl_keys = selected_keys &amp; set(tbl.keys())\n        data_keys = selected_keys &amp; set(self.data.keys())\n        assert tbl_keys.isdisjoint(data_keys)\n        res: dict[str, list[Any]] = {k: [] for k in selected_keys}\n        for index, site in enumerate(self.data[\"sequence\"]):\n            if selected_aas and site not in selected_aas:\n                continue\n            for k in tbl_keys:\n                res[k].append(tbl[k][index])\n            for k in data_keys:\n                res[k].append(self.data[k])  # will be the same for all sites\n\n        return res\n\n    def fetch_pdb(self, save_path: str | None = None, url: str | None = None) -&gt; None:\n        \"\"\"Fetches the PDB file for the protein (from the AlphaFold database by default).\n\n        Args:\n            save_path (str | None, optional): The path to save the PDB file to.\n                Defaults to `None`.\n            url (str | None, optional): The URL to fetch the PDB file from.\n                Defaults to `None`, in which case the AlphaFold database is used.\n\n        Raises:\n            Exception: If the response status code is not 200, meaning we could\n                not fetch the PDB from the database.\"\"\"\n        if not url:\n            url = f\"https://alphafold.ebi.ac.uk/files/AF-{self.data['entry']}-F1-model_v4.pdb\"\n        if not save_path:\n            save_path = f\"{self.data['entry']}.pdb\"\n\n        response = requests.get(url)\n\n        if response.status_code != 200:\n            raise Exception(f\"Failed to fetch PDB: {response.status_code}\")\n\n        with open(save_path, \"wb+\") as f:\n            f.write(response.content)\n\n        self.pdb_location_relative = save_path\n        self.pdb_location_absolute = os.path.abspath(save_path)\n\n    def register_local_pdb(self, path_to_pdb_file: str | None = None) -&gt; None:\n        \"\"\"Sets pdb file for protein object using local pdb file.\n\n        Args:\n            path_to_pdb_file (str | None, optional): Path to local PDB file.\n                Defaults to `None`, in which case it assumes a file with 'entry'.pdb.\"\"\"\n        if not path_to_pdb_file:\n            path_to_pdb_file = f\"{self.data['entry']}.pdb\"\n        self.pdb_location_relative = path_to_pdb_file\n        self.pdb_location_absolute = os.path.abspath(path_to_pdb_file)\n\n    def _is_site_aa(self, site: int, aa: AminoAcidLetter = \"C\") -&gt; bool:\n        if \"sequence\" not in self.data:\n            raise ValueError(\"Sequence entry not found in data\")\n\n        sequence = self.data[\"sequence\"]\n\n        return site &lt;= len(sequence) and sequence[site - 1] == aa\n</code></pre>"},{"location":"api/#procaliper.Protein.fetch_pdb","title":"<code>fetch_pdb(save_path=None, url=None)</code>","text":"<p>Fetches the PDB file for the protein (from the AlphaFold database by default).</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <code>str | None</code> <p>The path to save the PDB file to. Defaults to <code>None</code>.</p> <code>None</code> <code>url</code> <code>str | None</code> <p>The URL to fetch the PDB file from. Defaults to <code>None</code>, in which case the AlphaFold database is used.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the response status code is not 200, meaning we could not fetch the PDB from the database.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def fetch_pdb(self, save_path: str | None = None, url: str | None = None) -&gt; None:\n    \"\"\"Fetches the PDB file for the protein (from the AlphaFold database by default).\n\n    Args:\n        save_path (str | None, optional): The path to save the PDB file to.\n            Defaults to `None`.\n        url (str | None, optional): The URL to fetch the PDB file from.\n            Defaults to `None`, in which case the AlphaFold database is used.\n\n    Raises:\n        Exception: If the response status code is not 200, meaning we could\n            not fetch the PDB from the database.\"\"\"\n    if not url:\n        url = f\"https://alphafold.ebi.ac.uk/files/AF-{self.data['entry']}-F1-model_v4.pdb\"\n    if not save_path:\n        save_path = f\"{self.data['entry']}.pdb\"\n\n    response = requests.get(url)\n\n    if response.status_code != 200:\n        raise Exception(f\"Failed to fetch PDB: {response.status_code}\")\n\n    with open(save_path, \"wb+\") as f:\n        f.write(response.content)\n\n    self.pdb_location_relative = save_path\n    self.pdb_location_absolute = os.path.abspath(save_path)\n</code></pre>"},{"location":"api/#procaliper.Protein.from_uniprot_id","title":"<code>from_uniprot_id(uniprot_id, fields=None, from_db='UniProtKB_AC-ID', to_db='UniProtKB-Swiss-Prot')</code>  <code>classmethod</code>","text":"<p>Create a new Protein object from a Uniprot ID (fetches with Uniprot API)</p> <p>Parameters:</p> Name Type Description Default <code>uniprot_id</code> <code>str</code> <p>The Uniprot ID of the protein.</p> required <code>fields</code> <code>list[str] | None</code> <p>The fields to retrieve from Uniprot. If <code>None</code>, <code>Protein.UNIPROT_API_DEFAULT_FIELDS</code> is used.</p> <code>None</code> <code>from_db</code> <code>str</code> <p>The database to retrieve the ID from. Defaults to \"UniProtKB_AC-ID\".</p> <code>'UniProtKB_AC-ID'</code> <code>to_db</code> <code>str</code> <p>The database to map to. Defaults to \"UniProtKB-Swiss-Prot\".</p> <code>'UniProtKB-Swiss-Prot'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If we cannot retrieve the Uniprot ID.</p> <p>Returns:</p> Name Type Description <code>Protein</code> <code>Protein</code> <p>A processed and standardized protein object.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>@classmethod\ndef from_uniprot_id(\n    cls,\n    uniprot_id: str,\n    fields: list[str] | None = None,\n    from_db: str = \"UniProtKB_AC-ID\",\n    to_db: str = \"UniProtKB-Swiss-Prot\",\n) -&gt; Protein:\n    \"\"\"Create a new Protein object from a Uniprot ID (fetches with Uniprot API)\n\n    Args:\n        uniprot_id (str): The Uniprot ID of the protein.\n        fields (list[str] | None, optional): The fields to retrieve from\n            Uniprot. If `None`, `Protein.UNIPROT_API_DEFAULT_FIELDS` is used.\n        from_db (str, optional): The database to retrieve the ID from.\n            Defaults to \"UniProtKB_AC-ID\".\n        to_db (str, optional): The database to map to.\n            Defaults to \"UniProtKB-Swiss-Prot\".\n\n    Raises:\n        ValueError: If we cannot retrieve the Uniprot ID.\n\n    Returns:\n        Protein: A processed and standardized protein object.\n    \"\"\"\n\n    if not fields:\n        fields = cls.UNIPROT_API_DEFAULT_FIELDS\n\n    mapper = ProtMapper()\n\n    result, error = mapper.get(\n        ids=[uniprot_id], fields=fields, from_db=from_db, to_db=to_db\n    )\n    if error:\n        raise ValueError(f\"Uniprot id not retrieved: {error}\")\n    result.rename(columns={\"From\": \"entry\"}, inplace=True)\n    if \"Length\" in result.columns:\n        result[\"Length\"] = pd.to_numeric(result[\"Length\"])\n    return cls.from_uniprot_row(result.iloc[0].to_dict())\n</code></pre>"},{"location":"api/#procaliper.Protein.from_uniprot_row","title":"<code>from_uniprot_row(row)</code>  <code>classmethod</code>","text":"<p>Create a new Protein object from a row from a Uniprot table</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>dict[str, Any]</code> <p>Contains the data from the Uniprot table. Must have \"Sequence\" or \"sequence\" as a key.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If \"Sequence\" or \"sequence\" is not found in the row.</p> <p>Returns:</p> Name Type Description <code>Protein</code> <code>Protein</code> <p>A processed and standardized protein object.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>@classmethod\ndef from_uniprot_row(cls, row: dict[str, Any]) -&gt; Protein:\n    \"\"\"Create a new Protein object from a row from a Uniprot table\n\n    Args:\n        row (dict[str, Any]): Contains the data from the Uniprot table. Must\n            have \"Sequence\" or \"sequence\" as a key.\n\n    Raises:\n        ValueError: If \"Sequence\" or \"sequence\" is not found in the row.\n\n    Returns:\n        Protein: A processed and standardized protein object.\n    \"\"\"\n    p = cls()\n    if \"Sequence\" in row:\n        p.data[\"sequence\"] = row[\"Sequence\"]\n    elif \"sequence\" in row:\n        p.data[\"sequence\"] = row[\"sequence\"]\n    else:\n        raise ValueError(f\"Sequence not found in row: {row}\")\n    p.custom_site_data.add_residue_numbers(len(p.data[\"sequence\"]))\n    p.site_annotations = SiteAnnotations(p.data[\"sequence\"])\n    for key, value in row.items():\n        key = p._rectify_label(key)\n        if key in cls.UNIPROT_SITE_PATTERNS_RECTIFIED:\n            uniprot_description_id = cls.UNIPROT_SITE_PATTERNS_RECTIFIED[key]\n            p.site_annotations.extract_annotation(uniprot_description_id, value)\n        elif key in cls.UNIPROT_SITE_PATTERNS:\n            uniprot_description_id = cls.UNIPROT_SITE_PATTERNS[key]\n            p.site_annotations.extract_annotation(uniprot_description_id, value)\n        else:\n            if value != value:\n                value = \"\"\n            p.data[key] = value\n    return p\n</code></pre>"},{"location":"api/#procaliper.Protein.get_charge","title":"<code>get_charge(method='gasteiger')</code>","text":"<p>Fetches precomputed charge data for the protein, or computes it.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The method used for the charge calculation. Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to 'gasteiger'. For a full list reference https://open-babel.readthedocs.io/en/latest/Charges/charges.html</p> <code>'gasteiger'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>charge_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>ChargeData</code> <p>structure.charge.ChargeData: A :class:<code>protein_structure.charge.ChargeData</code> object containing the charge values for residues and atoms.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_charge(self, method: str = \"gasteiger\") -&gt; structure.charge.ChargeData:\n    \"\"\"Fetches precomputed charge data for the protein, or computes it.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Args:\n        method (str, optional): The method used for the charge calculation.\n            Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to\n            'gasteiger'. For a full list reference\n            https://open-babel.readthedocs.io/en/latest/Charges/charges.html\n\n    Raises:\n        ValueError: If `charge_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        structure.charge.ChargeData: A :class:`protein_structure.charge.ChargeData`\n            object containing the charge values for residues and atoms.\n    \"\"\"\n    if self.charge_data:\n        if self.charge_data[\"charge_method\"]:\n            if self.charge_data[\"charge_method\"][0] == method:\n                return self.charge_data\n\n    if self.pdb_location_absolute:\n        self.charge_data = structure.charge.calculate_charge(\n            self.pdb_location_absolute,\n            method=method,\n        )\n\n        self.last_charge_method = method\n\n        return self.charge_data\n    else:\n        raise ValueError(\n            \"Charge data for specified method not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_confidence","title":"<code>get_confidence()</code>","text":"<p>Fetches precomputed confidence data from pdb file.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>confidence_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: A list of confidence values for each residue.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_confidence(self) -&gt; list[float]:\n    \"\"\"Fetches precomputed confidence data from pdb file.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `confidence_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        list[float]: A list of confidence values for each residue.\n    \"\"\"\n    if self.confidence_data:\n        return self.confidence_data\n\n    if self.pdb_location_absolute:\n        self.confidence_data = structure.confidence.residue_pLDDT(\n            self.pdb_location_absolute,\n        )\n        return self.confidence_data\n    else:\n        raise ValueError(\n            \"Confidence data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_cysteine_data","title":"<code>get_cysteine_data()</code>","text":"<p>Fetches precomputed size data for the protein, or computes it.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>cysteine_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>CysteineData</code> <p>structure.size.CysteineData: A :class:<code>protein_structure.size.CysteineData</code> object containing the size values for cystein sites.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_cysteine_data(self) -&gt; structure.cysteine_data.CysteineData:\n    \"\"\"Fetches precomputed size data for the protein, or computes it.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `cysteine_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        structure.size.CysteineData: A :class:`protein_structure.size.CysteineData`\n            object containing the size values for cystein sites.\n    \"\"\"\n    if self.cysteine_data:\n        return self.cysteine_data\n\n    if self.pdb_location_absolute:\n        self.cysteine_data = structure.cysteine_data.calculate_cysteine_data(\n            self.pdb_location_absolute,\n        )\n        return self.cysteine_data\n    else:\n        raise ValueError(\n            \"Size data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_sasa","title":"<code>get_sasa()</code>","text":"<p>Fetches precomputed SASA data for the protein, or computes it.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>sasa_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>SASAData</code> <p>structure.sasa.SASAData: A :class:<code>protein_structure.sasa.SASAData</code> object containing the SASA values for residues and atoms.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_sasa(self) -&gt; structure.sasa.SASAData:\n    \"\"\"Fetches precomputed SASA data for the protein, or computes it.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `sasa_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        structure.sasa.SASAData: A :class:`protein_structure.sasa.SASAData`\n            object containing the SASA values for residues and atoms.\n    \"\"\"\n    if self.sasa_data:\n        return self.sasa_data\n\n    if self.pdb_location_absolute:\n        self.sasa_data = structure.sasa.calculate_sasa(\n            self.pdb_location_absolute,\n        )\n        return self.sasa_data\n    else:\n        raise ValueError(\n            \"SASA data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_titration","title":"<code>get_titration()</code>","text":"<p>Runs the default titration calculation for the protein.</p> <p>Equivalent to running <code>self.get_titration_from_propka</code>.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>titration_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>TitrationData</code> <p>structure.titration.TitrationData: A :class:<code>protein_structure.titration.TitrationData</code> object containing the titration values for residues.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_titration(self) -&gt; structure.titration.TitrationData:\n    \"\"\"Runs the default titration calculation for the protein.\n\n    Equivalent to running `self.get_titration_from_propka`.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `titration_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        structure.titration.TitrationData: A\n            :class:`protein_structure.titration.TitrationData` object containing\n            the titration values for residues.\n    \"\"\"\n    return self.get_titration_from_propka()\n</code></pre>"},{"location":"api/#procaliper.Protein.get_titration_from_pkai","title":"<code>get_titration_from_pkai()</code>","text":"<p>Fetches precomputed titration data for the protein, or computes it.</p> <p>Uses :func:<code>protein_structure.titration.calculate_titration_pkai</code> if <code>self.titration_data</code> is not already stored. Requires pkai to be installed. Note that this method is a deep-learning model, not a physics-based calculation.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>titration_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>structure.titration.TitrationData: A</p> Type Description <code>TitrationData</code> <p>the titration values for residues.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_titration_from_pkai(self) -&gt; structure.titration.TitrationData:\n    \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n    Uses :func:`protein_structure.titration.calculate_titration_pkai` if\n    `self.titration_data` is not already stored. Requires pkai to be\n    installed. Note that this method is a deep-learning model, not a\n    physics-based calculation.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `titration_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns: structure.titration.TitrationData: A\n        :class:`protein_structure.titration.TitrationData` object containing\n            the titration values for residues.\"\"\"\n    if self.titration_data:\n        return self.titration_data\n\n    if self.pdb_location_absolute:\n        self.titration_data = structure.titration.calculate_titration_pkai(\n            self.pdb_location_absolute,\n        )\n        return self.titration_data\n    else:\n        raise ValueError(\n            \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_titration_from_propka","title":"<code>get_titration_from_propka()</code>","text":"<p>Fetches precomputed titration data for the protein, or computes it.</p> <p>Uses :func:<code>protein_structure.titration.calculate_titration_propka</code> if <code>self.titration_data</code> is not already stored.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>titration_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>TitrationData</code> <p>structure.titration.TitrationData: A :class:<code>protein_structure.titration.TitrationData</code> object containing the titration values for residues.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_titration_from_propka(self) -&gt; structure.titration.TitrationData:\n    \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n    Uses :func:`protein_structure.titration.calculate_titration_propka` if\n    `self.titration_data` is not already stored.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `titration_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        structure.titration.TitrationData: A\n            :class:`protein_structure.titration.TitrationData` object containing\n            the titration values for residues.\"\"\"\n    if self.titration_data:\n        return self.titration_data\n\n    if self.pdb_location_absolute:\n        self.titration_data = structure.titration.calculate_titration_propka(\n            self.pdb_location_absolute,\n        )\n        return self.titration_data\n    else:\n        raise ValueError(\n            \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_titration_from_pypka","title":"<code>get_titration_from_pypka()</code>","text":"<p>Fetches precomputed titration data for the protein, or computes it.</p> <p>Uses :func:<code>protein_structure.titration.calculate_titration_pypka</code> if <code>self.titration_data</code> is not already stored. Requires pypka to be installed, which has dependencies that are not FOSS. Please be sure to verify that you are legally allowed to use pypka.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>titration_data</code> is not already stored and <code>pdb_location_absolute</code> is not set. ImportError: If pypka is not installed.</p> <p>Returns:</p> Type Description <code>TitrationData</code> <p>structure.titration.TitrationData: A :class:<code>protein_structure.titration.TitrationData</code> object containing the titration values forresidues.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_titration_from_pypka(self) -&gt; structure.titration.TitrationData:\n    \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n    Uses :func:`protein_structure.titration.calculate_titration_pypka` if\n    `self.titration_data` is not already stored. Requires pypka to be\n    installed, which has dependencies that are not FOSS. Please be sure to\n    verify that you are legally allowed to use pypka.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `titration_data` is not already stored and\n            `pdb_location_absolute` is not set. ImportError: If pypka is not\n            installed.\n\n    Returns:\n        structure.titration.TitrationData: A\n            :class:`protein_structure.titration.TitrationData` object containing\n            the titration values forresidues.\"\"\"\n\n    if self.titration_data:\n        return self.titration_data\n\n    if self.pdb_location_absolute:\n        self.titration_data = structure.titration.calculate_titration_pypka(\n            self.pdb_location_absolute,\n        )\n        return self.titration_data\n    else:\n        raise ValueError(\n            \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.list_from_uniprot_ids","title":"<code>list_from_uniprot_ids(uniprot_ids, fields=None, from_db='UniProtKB_AC-ID', to_db='UniProtKB-Swiss-Prot')</code>  <code>classmethod</code>","text":"<p>Create a list of Protein objects from a list of Uniprot IDs (fetches with Uniprot API)</p> <p>Parameters:</p> Name Type Description Default <code>uniprot_ids</code> <code>list[str]</code> <p>The Uniprot IDs of the proteins.</p> required <code>fields</code> <code>list[str] | None</code> <p>The fields to retrieve from Uniprot. If <code>None</code>, <code>Protein.UNIPROT_API_DEFAULT_FIELDS</code> is used.</p> <code>None</code> <code>from_db</code> <code>str</code> <p>The database to retrieve the IDs from. Defaults to \"UniProtKB_AC-ID\".</p> <code>'UniProtKB_AC-ID'</code> <code>to_db</code> <code>str</code> <p>The database to map to. Defaults to \"UniProtKB-Swiss-Prot\".</p> <code>'UniProtKB-Swiss-Prot'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If we cannot retrieve the Uniprot IDs.</p> <p>Returns:</p> Type Description <code>list[Protein]</code> <p>list[Protein]: A list of processed and standardized protein objects.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>@classmethod\ndef list_from_uniprot_ids(\n    cls,\n    uniprot_ids: list[str],\n    fields: list[str] | None = None,\n    from_db: str = \"UniProtKB_AC-ID\",\n    to_db: str = \"UniProtKB-Swiss-Prot\",\n) -&gt; list[Protein]:\n    \"\"\"Create a list of Protein objects from a list of Uniprot IDs (fetches with Uniprot API)\n\n    Args:\n        uniprot_ids (list[str]): The Uniprot IDs of the proteins.\n        fields (list[str] | None, optional): The fields to retrieve from\n            Uniprot. If `None`, `Protein.UNIPROT_API_DEFAULT_FIELDS` is used.\n        from_db (str, optional): The database to retrieve the IDs from.\n            Defaults to \"UniProtKB_AC-ID\".\n        to_db (str, optional): The database to map to.\n            Defaults to \"UniProtKB-Swiss-Prot\".\n\n    Raises:\n        ValueError: If we cannot retrieve the Uniprot IDs.\n\n    Returns:\n        list[Protein]: A list of processed and standardized protein objects.\n    \"\"\"\n    if not fields:\n        fields = cls.UNIPROT_API_DEFAULT_FIELDS\n\n    mapper = ProtMapper()\n\n    result, error = mapper.get(\n        ids=uniprot_ids, fields=fields, from_db=from_db, to_db=to_db\n    )\n    if error:\n        raise ValueError(f\"Uniprot id not retrieved: {error}\")\n    result.rename(columns={\"From\": \"entry\"}, inplace=True)\n\n    if \"Length\" in result.columns:\n        result[\"Length\"] = pd.to_numeric(result[\"Length\"])\n    return [cls.from_uniprot_row(row.to_dict()) for _, row in result.iterrows()]\n</code></pre>"},{"location":"api/#procaliper.Protein.register_local_pdb","title":"<code>register_local_pdb(path_to_pdb_file=None)</code>","text":"<p>Sets pdb file for protein object using local pdb file.</p> <p>Parameters:</p> Name Type Description Default <code>path_to_pdb_file</code> <code>str | None</code> <p>Path to local PDB file. Defaults to <code>None</code>, in which case it assumes a file with 'entry'.pdb.</p> <code>None</code> Source code in <code>procaliper/_protein.py</code> <pre><code>def register_local_pdb(self, path_to_pdb_file: str | None = None) -&gt; None:\n    \"\"\"Sets pdb file for protein object using local pdb file.\n\n    Args:\n        path_to_pdb_file (str | None, optional): Path to local PDB file.\n            Defaults to `None`, in which case it assumes a file with 'entry'.pdb.\"\"\"\n    if not path_to_pdb_file:\n        path_to_pdb_file = f\"{self.data['entry']}.pdb\"\n    self.pdb_location_relative = path_to_pdb_file\n    self.pdb_location_absolute = os.path.abspath(path_to_pdb_file)\n</code></pre>"},{"location":"api/#procaliper.Protein.unravel_sites","title":"<code>unravel_sites(selected_aas=None, selected_keys=None)</code>","text":"<p>Split the protein into individual sites, recording values for each.</p> <p>Parameters:</p> Name Type Description Default <code>selected_aas</code> <code>None | set[AminoAcidLetter]</code> <p>A set of amino acids letters to include in the output. If <code>None</code> (default), all amino acids will be included.</p> <code>None</code> <code>selected_keys</code> <code>None | set[str]</code> <p>A set of keys belonging to this <code>Protein</code> object's <code>data</code> dictionary to include in the output. If <code>None</code> (default), all keys are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, list[Any]]</code> <p>dict[str, list[Any]]: A dictionary mapping keys to lists of values. Each list is a parallel array of the same length as the protein sequence (after filtering out non-selected amino acids).</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def unravel_sites(\n    self,\n    selected_aas: None | set[AminoAcidLetter] = None,\n    selected_keys: None | set[str] = None,\n) -&gt; dict[str, list[Any]]:\n    \"\"\"Split the protein into individual sites, recording values for each.\n\n    Args:\n        selected_aas: A set of amino acids letters to include in the output.\n            If `None` (default), all amino acids will be included.\n        selected_keys: A set of keys belonging to this `Protein` object's\n            `data` dictionary to include in the output. If `None` (default),\n            all keys are used.\n\n    Returns:\n        dict[str, list[Any]]: A dictionary mapping keys to lists of values.\n            Each list is a parallel array of the same length as the protein\n            sequence (after filtering out non-selected amino acids).\"\"\"\n    tbl = self.site_annotations.table() | self.custom_site_data.table()\n    if selected_keys is None:\n        selected_keys = (set(tbl.keys()) | set(self.data.keys())) - {\"sequence\"}\n    tbl_keys = selected_keys &amp; set(tbl.keys())\n    data_keys = selected_keys &amp; set(self.data.keys())\n    assert tbl_keys.isdisjoint(data_keys)\n    res: dict[str, list[Any]] = {k: [] for k in selected_keys}\n    for index, site in enumerate(self.data[\"sequence\"]):\n        if selected_aas and site not in selected_aas:\n            continue\n        for k in tbl_keys:\n            res[k].append(tbl[k][index])\n        for k in data_keys:\n            res[k].append(self.data[k])  # will be the same for all sites\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure","title":"<code>protein_structure</code>","text":""},{"location":"api/#procaliper.protein_structure.calculate_charge","title":"<code>calculate_charge(pdb_filename, method='gasteiger')</code>","text":"<p>Computes the charge of residue sites in a PDB file.</p> <p>By default, the method used is 'gasteiger', but this is configurable in <code>hyperparameters.py</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file. shortname (str): The shortname of the protein (typically will be UniProt ID).</p> required <code>method</code> <code>str</code> <p>The method used for the charge calculation. Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to 'gasteiger'. For a full list reference https://open-babel.readthedocs.io/en/latest/Charges/charges.html</p> <code>'gasteiger'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the charge method is not found.</p> <p>Returns:</p> Name Type Description <code>ChargeData</code> <code>ChargeData</code> <p>A data class for holding charge data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/charge.py</code> <pre><code>def calculate_charge(pdb_filename: str, method: str = \"gasteiger\") -&gt; ChargeData:\n    \"\"\"Computes the charge of residue sites in a PDB file.\n\n    By default, the method used is 'gasteiger', but this is configurable in\n    `hyperparameters.py`.\n\n    Args:\n        pdb_filename (str): The path to the PDB file. shortname (str): The\n            shortname of the protein (typically will be UniProt ID).\n        method (str, optional): The method used for the charge calculation.\n            Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to\n            'gasteiger'. For a full list reference\n            https://open-babel.readthedocs.io/en/latest/Charges/charges.html\n\n\n    Raises:\n        ValueError: If the charge method is not found.\n\n    Returns:\n        ChargeData: A data class for holding charge data from computed from a\n            PDB file.\n    \"\"\"\n    pbmol = next(pybel.readfile(\"pdb\", pdb_filename))\n    mol = pbmol.OBMol\n\n    # Applies the model and computes charges.\n    ob_charge_model = ob.OBChargeModel.FindType(method)\n\n    if not ob_charge_model:\n        raise ValueError(\"Charge method not found. Please check hyperparameters.py\")\n    ob_charge_model.ComputeCharges(mol)\n\n    charges = cast(list[float], ob_charge_model.GetPartialCharges())\n\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)\n\n    # Set up dict\n    res = ChargeData(\n        {\n            \"charge\": [],\n            \"charge_method\": [],\n        }\n    )\n\n    for _, residue in sorted(ppdb.df[\"ATOM\"].groupby(\"residue_number\")):\n        res[\"charge\"].append([charges[x - 1] for x in sorted(residue[\"atom_number\"])])\n        res[\"charge_method\"].append(method)\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.calculate_cysteine_data","title":"<code>calculate_cysteine_data(pdb_filename)</code>","text":"<p>Calculates spatial data for a protein from a PDB file.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Name Type Description <code>CysteineData</code> <code>CysteineData</code> <p>A data class for holding size data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/cysteine_data.py</code> <pre><code>def calculate_cysteine_data(pdb_filename: str) -&gt; CysteineData:\n    \"\"\"Calculates spatial data for a protein from a PDB file.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        CysteineData: A data class for holding size data from computed from a PDB file.\n    \"\"\"\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)\n\n    res = CysteineData(\n        {\n            \"cys_ratio\": [],\n            \"min_dist_to_closest_sulfur\": [],\n            \"sulfur_closeness_rating_scaled\": [],\n        }\n    )\n\n    total_residue = cast(int, max(ppdb.df[\"ATOM\"][\"residue_number\"]))\n\n    cys_positions: list[tuple[float, float, float]] = []\n    for x in range(len(ppdb.df[\"ATOM\"])):\n        if ppdb.df[\"ATOM\"][\"residue_name\"][x] == \"CYS\":\n            if ppdb.df[\"ATOM\"][\"atom_name\"][x] == \"SG\":\n                cys_positions.append(\n                    (\n                        ppdb.df[\"ATOM\"][\"x_coord\"][x],\n                        ppdb.df[\"ATOM\"][\"y_coord\"][x],\n                        ppdb.df[\"ATOM\"][\"z_coord\"][x],\n                    )\n                )\n    total_cys_sites = len(cys_positions)\n\n    cys_index = 0\n\n    for _, grp in sorted(ppdb.df[\"ATOM\"].groupby(\"residue_number\")):\n        if grp[\"residue_name\"].max() == \"CYS\":\n            sg_closeness_rating_scaled = 0\n            x_p, y_p, z_p = cys_positions[cys_index]\n            min_distance = 1000  # Initialize with a large number\n\n            points_excluding_index = (\n                cys_positions[:cys_index] + cys_positions[cys_index + 1 :]\n            )\n            for point in points_excluding_index:\n                x_q, y_q, z_q = point\n                distance = np.sqrt(\n                    (x_p - x_q) ** 2 + (y_p - y_q) ** 2 + (z_p - z_q) ** 2\n                )\n                if distance &lt; min_distance:\n                    min_distance = distance\n                sg_closeness_rating_scaled += 10 / ((distance + 1) ** 2)\n\n            cys_index += 1\n\n            res[\"cys_ratio\"].append(float(total_cys_sites) / float(total_residue))\n            res[\"min_dist_to_closest_sulfur\"].append(min_distance)\n            res[\"sulfur_closeness_rating_scaled\"].append(sg_closeness_rating_scaled)\n        else:\n            res[\"cys_ratio\"].append(None)\n            res[\"min_dist_to_closest_sulfur\"].append(None)\n            res[\"sulfur_closeness_rating_scaled\"].append(None)\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.calculate_sasa","title":"<code>calculate_sasa(pdb_filename)</code>","text":"<p>Compute the SASA values for all CYS sites in a PDB file.</p> <p>Uses the ShrakeRupley algorithm implemented in <code>Bio.PDB.SASA.ShrakeRupley</code> with a probe radius of 1.40 and 100 points.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Name Type Description <code>SASAData</code> <code>SASAData</code> <p>A data class for holding SASA data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/sasa.py</code> <pre><code>def calculate_sasa(pdb_filename: str) -&gt; SASAData:\n    \"\"\"Compute the SASA values for all CYS sites in a PDB file.\n\n    Uses the ShrakeRupley algorithm implemented in `Bio.PDB.SASA.ShrakeRupley`\n    with a probe radius of 1.40 and 100 points.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        SASAData: A data class for holding SASA data from computed from a PDB\n            file.\"\"\"\n    p = PDBParser(QUIET=True)\n    struct = p.get_structure(\"\", pdb_filename)\n\n    sr = ShrakeRupley(probe_radius=PROBE_RADIUS, n_points=N_POINTS, radii_dict=None)\n\n    # Calc sasa values from Residues (from atoms)\n    sr.compute(struct, level=\"R\")\n\n    # Set up dict\n    res = SASAData(\n        {\n            \"all_sasa_value\": [],\n            \"atom_sasa_values\": [],\n        }\n    )\n\n    assert isinstance(struct, Structure)\n    assert struct is not None\n\n    # Fill dict with CYS sites\n    for x in struct.child_list:\n        for y in x.child_list:\n            for z in y.child_list:\n                assert hasattr(z, \"sasa\")\n                res[\"all_sasa_value\"].append(z.sasa)\n                res[\"atom_sasa_values\"].append([zx.sasa for zx in z.child_list])  # type: ignore\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.residue_pLDDT","title":"<code>residue_pLDDT(pdb_filename)</code>","text":"<p>Extracts the pLDDT confidence for each residue in a PDB file.</p> <p>We assume that the pLDDT confidences are in the B-factor entries of the PDB file. If this information is provided at the atom-level, the maximimum value across the residue is used.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: The pLDDT confidence for each residue in the PDB file.</p> Source code in <code>procaliper/protein_structure/confidence.py</code> <pre><code>def residue_pLDDT(pdb_filename: str) -&gt; list[float]:\n    \"\"\"Extracts the pLDDT confidence for each residue in a PDB file.\n\n    We assume that the pLDDT confidences are in the B-factor entries of the PDB\n    file. If this information is provided at the atom-level, the maximimum value\n    across the residue is used.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        list[float]: The pLDDT confidence for each residue in the PDB file.\n    \"\"\"\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)\n\n    vals = []\n    for _, res in ppdb.df[\"ATOM\"].groupby(\"residue_number\"):\n        vals.append(res[\"b_factor\"].max())\n\n    return vals\n</code></pre>"},{"location":"api/#procaliper.protein_structure.charge","title":"<code>charge</code>","text":""},{"location":"api/#procaliper.protein_structure.charge.ChargeData","title":"<code>ChargeData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>A data class for holding charge data from computed from a PDB file.</p> <p>Array index corresponds to residue number in the PDB. Note that Python arrays are 0-indexed and PDB files are 1-indexed, so Python index 0 corresponds to residue 1.</p> <p>Attributes:</p> Name Type Description <code>charges</code> <code>list[list[float]]</code> <p>The charge value for atoms in the residue, ordered from C-terminus to N-terminus according to standard pdb order. For example, in CYS, the last atom is always the SG sulfur.</p> <code>method</code> <code>list[str]</code> <p>The method used for the charge calculation.</p> <code>residue_number</code> <code>list[int]</code> <p>The residue number for the site.</p> <code>residue_name</code> <code>list[str]</code> <p>The residue name (three-letter amino acid abbreviation) for the sites.</p> Source code in <code>procaliper/protein_structure/charge.py</code> <pre><code>class ChargeData(TypedDict):\n    \"\"\"\n    A data class for holding charge data from computed from a PDB file.\n\n    Array index corresponds to residue number in the PDB. Note that Python\n    arrays are 0-indexed and PDB files are 1-indexed, so Python index 0\n    corresponds to residue 1.\n\n    Attributes:\n        charges (list[list[float]]): The charge value for atoms in the residue,\n            ordered from C-terminus to N-terminus according to standard pdb order.\n            For example, in CYS, the last atom is always the SG sulfur.\n        method (list[str]): The method used for the charge calculation.\n        residue_number (list[int]): The residue number for the site.\n        residue_name (list[str]): The residue name (three-letter amino acid\n            abbreviation) for the sites.\n    \"\"\"\n\n    charge: list[list[float]]\n    charge_method: list[str]\n</code></pre>"},{"location":"api/#procaliper.protein_structure.charge.calculate_charge","title":"<code>calculate_charge(pdb_filename, method='gasteiger')</code>","text":"<p>Computes the charge of residue sites in a PDB file.</p> <p>By default, the method used is 'gasteiger', but this is configurable in <code>hyperparameters.py</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file. shortname (str): The shortname of the protein (typically will be UniProt ID).</p> required <code>method</code> <code>str</code> <p>The method used for the charge calculation. Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to 'gasteiger'. For a full list reference https://open-babel.readthedocs.io/en/latest/Charges/charges.html</p> <code>'gasteiger'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the charge method is not found.</p> <p>Returns:</p> Name Type Description <code>ChargeData</code> <code>ChargeData</code> <p>A data class for holding charge data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/charge.py</code> <pre><code>def calculate_charge(pdb_filename: str, method: str = \"gasteiger\") -&gt; ChargeData:\n    \"\"\"Computes the charge of residue sites in a PDB file.\n\n    By default, the method used is 'gasteiger', but this is configurable in\n    `hyperparameters.py`.\n\n    Args:\n        pdb_filename (str): The path to the PDB file. shortname (str): The\n            shortname of the protein (typically will be UniProt ID).\n        method (str, optional): The method used for the charge calculation.\n            Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to\n            'gasteiger'. For a full list reference\n            https://open-babel.readthedocs.io/en/latest/Charges/charges.html\n\n\n    Raises:\n        ValueError: If the charge method is not found.\n\n    Returns:\n        ChargeData: A data class for holding charge data from computed from a\n            PDB file.\n    \"\"\"\n    pbmol = next(pybel.readfile(\"pdb\", pdb_filename))\n    mol = pbmol.OBMol\n\n    # Applies the model and computes charges.\n    ob_charge_model = ob.OBChargeModel.FindType(method)\n\n    if not ob_charge_model:\n        raise ValueError(\"Charge method not found. Please check hyperparameters.py\")\n    ob_charge_model.ComputeCharges(mol)\n\n    charges = cast(list[float], ob_charge_model.GetPartialCharges())\n\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)\n\n    # Set up dict\n    res = ChargeData(\n        {\n            \"charge\": [],\n            \"charge_method\": [],\n        }\n    )\n\n    for _, residue in sorted(ppdb.df[\"ATOM\"].groupby(\"residue_number\")):\n        res[\"charge\"].append([charges[x - 1] for x in sorted(residue[\"atom_number\"])])\n        res[\"charge_method\"].append(method)\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.confidence","title":"<code>confidence</code>","text":""},{"location":"api/#procaliper.protein_structure.confidence.residue_pLDDT","title":"<code>residue_pLDDT(pdb_filename)</code>","text":"<p>Extracts the pLDDT confidence for each residue in a PDB file.</p> <p>We assume that the pLDDT confidences are in the B-factor entries of the PDB file. If this information is provided at the atom-level, the maximimum value across the residue is used.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: The pLDDT confidence for each residue in the PDB file.</p> Source code in <code>procaliper/protein_structure/confidence.py</code> <pre><code>def residue_pLDDT(pdb_filename: str) -&gt; list[float]:\n    \"\"\"Extracts the pLDDT confidence for each residue in a PDB file.\n\n    We assume that the pLDDT confidences are in the B-factor entries of the PDB\n    file. If this information is provided at the atom-level, the maximimum value\n    across the residue is used.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        list[float]: The pLDDT confidence for each residue in the PDB file.\n    \"\"\"\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)\n\n    vals = []\n    for _, res in ppdb.df[\"ATOM\"].groupby(\"residue_number\"):\n        vals.append(res[\"b_factor\"].max())\n\n    return vals\n</code></pre>"},{"location":"api/#procaliper.protein_structure.cysteine_data","title":"<code>cysteine_data</code>","text":""},{"location":"api/#procaliper.protein_structure.cysteine_data.CysteineData","title":"<code>CysteineData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Data class for holding size data from computed from a PDB file.</p> <p>Non-CYS sites are assigned <code>None</code> values.</p> <p>Array index corresponds to residue number in the PDB. Note that Python arrays are 0-indexed and PDB files are 1-indexed, so Python index 0 corresponds to residue 1.</p> <p>Attributes:</p> Name Type Description <code>cys_ratio</code> <code>list[float | None]</code> <p>The ratio of CYS sites to total sites.</p> <code>min_dist_to_closest_sulfur</code> <code>list[float | None]</code> <p>The minimum distance to the closest sulfur for each CYS site.</p> <code>sulfur_closeness_rating_scaled</code> <code>list[float | None]</code> <p>The sulfur closeness rating scaled for the CYS sites.</p> Source code in <code>procaliper/protein_structure/cysteine_data.py</code> <pre><code>class CysteineData(TypedDict):\n    \"\"\"Data class for holding size data from computed from a PDB file.\n\n    Non-CYS sites are assigned `None` values.\n\n    Array index corresponds to residue number in the PDB. Note that Python\n    arrays are 0-indexed and PDB files are 1-indexed, so Python index 0\n    corresponds to residue 1.\n\n    Attributes:\n        cys_ratio (list[float | None]): The ratio of CYS sites to total sites.\n        min_dist_to_closest_sulfur (list[float | None]): The minimum distance to the closest sulfur for each CYS site.\n        sulfur_closeness_rating_scaled (list[float | None]): The sulfur closeness rating scaled for the CYS sites.\"\"\"\n\n    cys_ratio: list[float | None]\n    min_dist_to_closest_sulfur: list[float | None]\n    sulfur_closeness_rating_scaled: list[float | None]\n</code></pre>"},{"location":"api/#procaliper.protein_structure.cysteine_data.calculate_cysteine_data","title":"<code>calculate_cysteine_data(pdb_filename)</code>","text":"<p>Calculates spatial data for a protein from a PDB file.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Name Type Description <code>CysteineData</code> <code>CysteineData</code> <p>A data class for holding size data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/cysteine_data.py</code> <pre><code>def calculate_cysteine_data(pdb_filename: str) -&gt; CysteineData:\n    \"\"\"Calculates spatial data for a protein from a PDB file.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        CysteineData: A data class for holding size data from computed from a PDB file.\n    \"\"\"\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)\n\n    res = CysteineData(\n        {\n            \"cys_ratio\": [],\n            \"min_dist_to_closest_sulfur\": [],\n            \"sulfur_closeness_rating_scaled\": [],\n        }\n    )\n\n    total_residue = cast(int, max(ppdb.df[\"ATOM\"][\"residue_number\"]))\n\n    cys_positions: list[tuple[float, float, float]] = []\n    for x in range(len(ppdb.df[\"ATOM\"])):\n        if ppdb.df[\"ATOM\"][\"residue_name\"][x] == \"CYS\":\n            if ppdb.df[\"ATOM\"][\"atom_name\"][x] == \"SG\":\n                cys_positions.append(\n                    (\n                        ppdb.df[\"ATOM\"][\"x_coord\"][x],\n                        ppdb.df[\"ATOM\"][\"y_coord\"][x],\n                        ppdb.df[\"ATOM\"][\"z_coord\"][x],\n                    )\n                )\n    total_cys_sites = len(cys_positions)\n\n    cys_index = 0\n\n    for _, grp in sorted(ppdb.df[\"ATOM\"].groupby(\"residue_number\")):\n        if grp[\"residue_name\"].max() == \"CYS\":\n            sg_closeness_rating_scaled = 0\n            x_p, y_p, z_p = cys_positions[cys_index]\n            min_distance = 1000  # Initialize with a large number\n\n            points_excluding_index = (\n                cys_positions[:cys_index] + cys_positions[cys_index + 1 :]\n            )\n            for point in points_excluding_index:\n                x_q, y_q, z_q = point\n                distance = np.sqrt(\n                    (x_p - x_q) ** 2 + (y_p - y_q) ** 2 + (z_p - z_q) ** 2\n                )\n                if distance &lt; min_distance:\n                    min_distance = distance\n                sg_closeness_rating_scaled += 10 / ((distance + 1) ** 2)\n\n            cys_index += 1\n\n            res[\"cys_ratio\"].append(float(total_cys_sites) / float(total_residue))\n            res[\"min_dist_to_closest_sulfur\"].append(min_distance)\n            res[\"sulfur_closeness_rating_scaled\"].append(sg_closeness_rating_scaled)\n        else:\n            res[\"cys_ratio\"].append(None)\n            res[\"min_dist_to_closest_sulfur\"].append(None)\n            res[\"sulfur_closeness_rating_scaled\"].append(None)\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.sasa","title":"<code>sasa</code>","text":""},{"location":"api/#procaliper.protein_structure.sasa.SASAData","title":"<code>SASAData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Data class for holding SASA data from computed from a PDB file.</p> <p>Array index corresponds to residue number in the PDB. Note that Python arrays are 0-indexed and PDB files are 1-indexed, so Python index 0 corresponds to residue 1.</p> <p>Attributes:</p> Name Type Description <code>all_sasa_value</code> <code>list[float]</code> <p>The overall SASA value for each site (computed as sum of atom SASA values).</p> <code>atom_sasa_values</code> <code>list[list[float]]</code> <p>The SASA value for the each atom in each sites. Atoms are ordered from C-terminus to N-terminus according to standard pdb order. For example, in CYS, the last atom is always the SG sulfur.</p> Source code in <code>procaliper/protein_structure/sasa.py</code> <pre><code>class SASAData(TypedDict):\n    \"\"\"Data class for holding SASA data from computed from a PDB file.\n\n    Array index corresponds to residue number in the PDB. Note that Python\n    arrays are 0-indexed and PDB files are 1-indexed, so Python index 0\n    corresponds to residue 1.\n\n    Attributes:\n        all_sasa_value (list[float]): The overall SASA value for each site\n            (computed as sum of atom SASA values).\n        atom_sasa_values (list[list[float]]): The SASA value for the each atom\n            in each sites. Atoms are ordered from C-terminus to N-terminus\n            according to standard pdb order. For example, in CYS, the last atom\n            is always the SG sulfur.\n    \"\"\"\n\n    all_sasa_value: list[float]\n    atom_sasa_values: list[list[float]]\n</code></pre>"},{"location":"api/#procaliper.protein_structure.sasa.calculate_sasa","title":"<code>calculate_sasa(pdb_filename)</code>","text":"<p>Compute the SASA values for all CYS sites in a PDB file.</p> <p>Uses the ShrakeRupley algorithm implemented in <code>Bio.PDB.SASA.ShrakeRupley</code> with a probe radius of 1.40 and 100 points.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Name Type Description <code>SASAData</code> <code>SASAData</code> <p>A data class for holding SASA data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/sasa.py</code> <pre><code>def calculate_sasa(pdb_filename: str) -&gt; SASAData:\n    \"\"\"Compute the SASA values for all CYS sites in a PDB file.\n\n    Uses the ShrakeRupley algorithm implemented in `Bio.PDB.SASA.ShrakeRupley`\n    with a probe radius of 1.40 and 100 points.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        SASAData: A data class for holding SASA data from computed from a PDB\n            file.\"\"\"\n    p = PDBParser(QUIET=True)\n    struct = p.get_structure(\"\", pdb_filename)\n\n    sr = ShrakeRupley(probe_radius=PROBE_RADIUS, n_points=N_POINTS, radii_dict=None)\n\n    # Calc sasa values from Residues (from atoms)\n    sr.compute(struct, level=\"R\")\n\n    # Set up dict\n    res = SASAData(\n        {\n            \"all_sasa_value\": [],\n            \"atom_sasa_values\": [],\n        }\n    )\n\n    assert isinstance(struct, Structure)\n    assert struct is not None\n\n    # Fill dict with CYS sites\n    for x in struct.child_list:\n        for y in x.child_list:\n            for z in y.child_list:\n                assert hasattr(z, \"sasa\")\n                res[\"all_sasa_value\"].append(z.sasa)\n                res[\"atom_sasa_values\"].append([zx.sasa for zx in z.child_list])  # type: ignore\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.titration","title":"<code>titration</code>","text":""},{"location":"api/#procaliper.protein_structure.titration.TitrationData","title":"<code>TitrationData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Data class for titration data.</p> <p>Array index corresponds to residue number in the PDB. Note that Python arrays are 0-indexed and PDB files are 1-indexed, so Python index 0 corresponds to residue 1.</p> <p>Attributes:</p> Name Type Description <code>pKa</code> <code>list[float | None]</code> <p>The pKa values for the titration data. Non-titratable sites are assigned <code>None</code> values. protonation_state</p> <code>(list[tuple[str,</code> <code>float]]</code> <p>The expected protonation states for the titration data. The first element of the tuple is the state of the site and the second element is the average protonation of the site. Non-titratable sites are assigned <code>(\"undefined\", nan)</code>.</p> Source code in <code>procaliper/protein_structure/titration.py</code> <pre><code>class TitrationData(TypedDict):\n    \"\"\"Data class for titration data.\n\n    Array index corresponds to residue number in the PDB. Note that Python\n    arrays are 0-indexed and PDB files are 1-indexed, so Python index 0\n    corresponds to residue 1.\n\n    Attributes:\n        pKa (list[float | None]): The pKa values for the titration data.\n            Non-titratable sites are assigned `None` values. protonation_state\n        (list[tuple[str, float]]): The expected protonation states for the\n            titration data. The first element of the tuple is the state of the\n            site and the second element is the average protonation of the site.\n            Non-titratable sites are assigned `(\"undefined\", nan)`.\n    \"\"\"\n\n    pKa: list[float | None]\n    protonation_state: list[tuple[str, float | str]]\n</code></pre>"},{"location":"api/#procaliper.protein_structure.titration.calculate_titration_propka","title":"<code>calculate_titration_propka(pdb_filename)</code>","text":"<p>Uses propka to calculate titration data for the protein.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Name Type Description <code>TitrationData</code> <code>TitrationData</code> <p>The titration data for the protein.</p> Source code in <code>procaliper/protein_structure/titration.py</code> <pre><code>def calculate_titration_propka(pdb_filename: str) -&gt; TitrationData:\n    \"\"\"Uses propka to calculate titration data for the protein.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        TitrationData: The titration data for the protein.\n    \"\"\"\n    mol = propka.run.single(pdb_filename, optargs=[\"--quiet\"], write_pka=False)\n    gs = mol.conformations[\"AVR\"].groups\n\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)\n\n    seq = {\n        i: res[\"residue_name\"].iloc[0]\n        for i, res in ppdb.df[\"ATOM\"].groupby(\"residue_number\")\n    }\n    pks = {group.atom.res_num: group.pka_value for group in gs}\n    sv = sorted(seq.items())\n    return TitrationData(\n        # pKa=[group.pka_value for group in gs],\n        pKa=[pks[i] if i in pks else None for i, _ in sv],\n        protonation_state=[_state_from_pk(pks[i] if i in pks else 0) for i, _ in sv],\n    )\n</code></pre>"},{"location":"api/#procaliper.view","title":"<code>view</code>","text":""},{"location":"api/#procaliper.view.ngl_scheme","title":"<code>ngl_scheme(data, float_to_hex=None, two_sided=False)</code>","text":"<p>Converts a list of values to an nglview color scheme.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[float]</code> <p>The list of values to convert.</p> required <code>float_to_hex</code> <code>Callable[[float], str] | None</code> <p>Function that converts a float to a hex color in the form <code>\"#RRGGBB\"</code>. If <code>None</code>, a default function is used that interpolates between white and green (one-sided) or red and blue (two-sided). Defaults to <code>None</code>.</p> <code>None</code> <code>two_sided</code> <code>bool</code> <p>Whether to use a two-sided color scheme. If <code>False</code>, we assume <code>data</code> only contains positive values. Defaults to <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>list[tuple[str, str]]: A list of color and residue number tuples that are compatible with nglview.</p> Source code in <code>procaliper/view/nglview_utils.py</code> <pre><code>def ngl_scheme(\n    data: list[float],\n    float_to_hex: Callable[[float], str] | None = None,\n    two_sided: bool = False,\n) -&gt; list[tuple[str, str]]:\n    \"\"\"Converts a list of values to an nglview color scheme.\n\n    Args:\n        data (list[float]): The list of values to convert.\n        float_to_hex (Callable[[float], str] | None, optional): Function that\n            converts a float to a hex color in the form `\"#RRGGBB\"`. If `None`,\n            a default function is used that interpolates between white and green\n            (one-sided) or red and blue (two-sided). Defaults to `None`.\n        two_sided (bool, optional): Whether to use a two-sided color scheme. If\n            `False`, we assume `data` only contains positive values. Defaults to\n            `False`.\n\n    Returns:\n        list[tuple[str, str]]: A list of color and residue number tuples that\n            are compatible with nglview.\n    \"\"\"\n    if float_to_hex is None:\n        if two_sided:\n            float_to_hex = _default_float_to_hex_rb\n        else:\n            float_to_hex = _default_float_to_hex\n\n    maxx = max(data)\n    scale = max(min(data), abs(maxx)) if two_sided else maxx\n\n    if scale == 0:\n        data_scaled = [0.0] * len(data)\n    else:\n        data_scaled = [x / maxx for x in data]\n\n    return [(float_to_hex(x), f\"{i+1}\") for i, x in enumerate(data_scaled)]\n</code></pre>"},{"location":"api/#procaliper.view.protein_to_nglview","title":"<code>protein_to_nglview(protein)</code>","text":"<p>Generates an nglview widget from a protein that has an associated PDB file.</p> <p>Must run <code>protein.fetch_pdb</code> first or specify an abosulute path to the PDB in <code>protein.pdb_location_absolute</code>.</p> <p>Parameters:</p> Name Type Description Default <code>protein</code> <code>Protein</code> <p>The protein object to visualize.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the PDB location is not set.</p> <p>Returns:</p> Type Description <code>NGLWidget</code> <p>nglview.NGLWidget: an nglview widget</p> Source code in <code>procaliper/view/nglview_utils.py</code> <pre><code>def protein_to_nglview(protein: Protein) -&gt; nglview.NGLWidget:\n    \"\"\"Generates an nglview widget from a protein that has an associated PDB file.\n\n    Must run `protein.fetch_pdb` first or specify an abosulute path to the PDB\n    in `protein.pdb_location_absolute`.\n\n    Args:\n        protein (Protein): The protein object to visualize.\n\n    Raises:\n        ValueError: If the PDB location is not set.\n\n    Returns:\n        nglview.NGLWidget: an nglview widget\n    \"\"\"\n    if not protein.pdb_location_absolute:\n        raise ValueError(\"PDB location not set; use `fetch_pdb` first\")\n    return nglview.show_file(protein.pdb_location_absolute)\n</code></pre>"},{"location":"api/#procaliper.view.nglview_utils","title":"<code>nglview_utils</code>","text":""},{"location":"api/#procaliper.view.nglview_utils.ngl_scheme","title":"<code>ngl_scheme(data, float_to_hex=None, two_sided=False)</code>","text":"<p>Converts a list of values to an nglview color scheme.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[float]</code> <p>The list of values to convert.</p> required <code>float_to_hex</code> <code>Callable[[float], str] | None</code> <p>Function that converts a float to a hex color in the form <code>\"#RRGGBB\"</code>. If <code>None</code>, a default function is used that interpolates between white and green (one-sided) or red and blue (two-sided). Defaults to <code>None</code>.</p> <code>None</code> <code>two_sided</code> <code>bool</code> <p>Whether to use a two-sided color scheme. If <code>False</code>, we assume <code>data</code> only contains positive values. Defaults to <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>list[tuple[str, str]]: A list of color and residue number tuples that are compatible with nglview.</p> Source code in <code>procaliper/view/nglview_utils.py</code> <pre><code>def ngl_scheme(\n    data: list[float],\n    float_to_hex: Callable[[float], str] | None = None,\n    two_sided: bool = False,\n) -&gt; list[tuple[str, str]]:\n    \"\"\"Converts a list of values to an nglview color scheme.\n\n    Args:\n        data (list[float]): The list of values to convert.\n        float_to_hex (Callable[[float], str] | None, optional): Function that\n            converts a float to a hex color in the form `\"#RRGGBB\"`. If `None`,\n            a default function is used that interpolates between white and green\n            (one-sided) or red and blue (two-sided). Defaults to `None`.\n        two_sided (bool, optional): Whether to use a two-sided color scheme. If\n            `False`, we assume `data` only contains positive values. Defaults to\n            `False`.\n\n    Returns:\n        list[tuple[str, str]]: A list of color and residue number tuples that\n            are compatible with nglview.\n    \"\"\"\n    if float_to_hex is None:\n        if two_sided:\n            float_to_hex = _default_float_to_hex_rb\n        else:\n            float_to_hex = _default_float_to_hex\n\n    maxx = max(data)\n    scale = max(min(data), abs(maxx)) if two_sided else maxx\n\n    if scale == 0:\n        data_scaled = [0.0] * len(data)\n    else:\n        data_scaled = [x / maxx for x in data]\n\n    return [(float_to_hex(x), f\"{i+1}\") for i, x in enumerate(data_scaled)]\n</code></pre>"},{"location":"api/#procaliper.view.nglview_utils.protein_to_nglview","title":"<code>protein_to_nglview(protein)</code>","text":"<p>Generates an nglview widget from a protein that has an associated PDB file.</p> <p>Must run <code>protein.fetch_pdb</code> first or specify an abosulute path to the PDB in <code>protein.pdb_location_absolute</code>.</p> <p>Parameters:</p> Name Type Description Default <code>protein</code> <code>Protein</code> <p>The protein object to visualize.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the PDB location is not set.</p> <p>Returns:</p> Type Description <code>NGLWidget</code> <p>nglview.NGLWidget: an nglview widget</p> Source code in <code>procaliper/view/nglview_utils.py</code> <pre><code>def protein_to_nglview(protein: Protein) -&gt; nglview.NGLWidget:\n    \"\"\"Generates an nglview widget from a protein that has an associated PDB file.\n\n    Must run `protein.fetch_pdb` first or specify an abosulute path to the PDB\n    in `protein.pdb_location_absolute`.\n\n    Args:\n        protein (Protein): The protein object to visualize.\n\n    Raises:\n        ValueError: If the PDB location is not set.\n\n    Returns:\n        nglview.NGLWidget: an nglview widget\n    \"\"\"\n    if not protein.pdb_location_absolute:\n        raise ValueError(\"PDB location not set; use `fetch_pdb` first\")\n    return nglview.show_file(protein.pdb_location_absolute)\n</code></pre>"},{"location":"authors/","title":"authors","text":""},{"location":"authors/#credits","title":"Credits","text":"<ul> <li>Song Feng song.feng@pnnl.gov</li> <li>Ally Im alexandria.im@pnnl.gov</li> <li>Doo Nam Kim doonam.kim@pnnl.gov</li> <li>Jordan Rozum jordan.rozum@pnnl.gov</li> <li>Hunter Ufford hunter.ufford@pnnl.gov</li> </ul>"},{"location":"contributing/","title":"contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/PhenoMeters/procaliper/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>procaliper could always use more documentation, whether as part of the official procaliper docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/PhenoMeters/procaliper/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>procaliper</code> for local development.</p> <ol> <li>Fork the <code>procaliper</code> repo on GitHub.</li> <li>Clone your fork locally</li> </ol> <pre><code>    $ git clone git@github.com:your_name_here/procaliper.git\n</code></pre> <ol> <li>Ensure poetry is installed.</li> <li>Install dependencies and start your virtualenv:</li> </ol> <p><pre><code>    $ poetry install -E \"test doc dev\"\n</code></pre> The above command will install the optional dependencies needed for developement. See <code>pyproject.toml</code> for additional features to install.</p> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>    $ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</li> </ol> <pre><code>    $ poetry run tox\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>    $ git add .\n    $ git commit -m \"Your detailed description of your changes.\"\n    $ git push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python &gt;=3.9. Check    https://github.com/PhenoMeters/procaliper/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips","text":"<p>To run a specific test: <pre><code>    $ poetry run python -m pytest .\\tests\\test_site_annotation.py -k \"test_site_annotations_with_data\"\n</code></pre></p>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run:</p> <pre><code>$ poetry patch # possible: major / minor / patch\n$ git push\n$ git push --tags\n</code></pre> <p>Github Actions will then deploy to PyPI if tests pass.</p>"},{"location":"history/","title":"history","text":""},{"location":"history/#history","title":"History","text":""},{"location":"history/#010-2024-01-08","title":"0.1.0 (2024-01-08)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"installation/","title":"installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install procaliper, run this command in your terminal:</p> <pre><code>pip install procaliper\n</code></pre> <p>This is the preferred method to install procaliper, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for procaliper can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>git clone git://github.com/LifeWorks/procaliper\n</code></pre> <p>Or download the tarball:</p> <pre><code>curl -OJL https://github.com/LifeWorks/procaliper/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>pip install .\n</code></pre>"},{"location":"usage/","title":"usage","text":""},{"location":"usage/#usage","title":"Usage","text":"<p>To use procaliper in a project</p> <pre><code>    import procaliper\n</code></pre>"}]}