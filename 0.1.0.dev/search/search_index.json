{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"home","text":""},{"location":"#procaliper","title":"procaliper","text":"<p>A tool for fetching and organizing protein data in order to perform structure calculations.</p>"},{"location":"#installation","title":"Installation","text":"<p>Available on PyPI </p> <p>Currently, installing from this repo (see Contributing section below) is the best way to install <code>procaliper</code>, as it is still a work-in-progress!</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome!</p> <p>See Contributing for detailed instructions.</p>"},{"location":"#license","title":"License","text":"<p>This code is released under GPL v3. See our License for detailed information.</p> <p>Please note that some optional dependencies may require proprietary licenses.</p>"},{"location":"#credits","title":"Credits","text":"<p>This work is supported by the Predictive Phenomics Initiative at Pacific Northwest National Laboratory.</p>"},{"location":"api/","title":"modules","text":"<p>Top-level package for procaliper.</p>"},{"location":"api/#procaliper.Protein","title":"<code>Protein</code>","text":"Source code in <code>procaliper/_protein.py</code> <pre><code>class Protein:\n    UNIPROT_SITE_PATTERNS = {\n        \"Active site\": [(r\"ACT_SITE (\\d+);\", False)],\n        \"Binding site\": [\n            (r\"BINDING (\\d+);\", False),\n            (r\"BINDING (\\d+)\\.\\.(\\d+);\", False),\n        ],\n        \"DNA binding\": [\n            (r\"DNA_BIND (\\d+);\", False),\n            (r\"DNA_BIND (\\d+)\\.\\.(\\d+);\", False),\n        ],\n        \"Disulfide bond\": [\n            (r\"DISULFID (\\d+);\", False),\n            (r\"DISULFID (\\d+)\\.\\.(\\d+);\", False),\n        ],\n        \"Beta strand\": [(r\"STRAND (\\d+);\", True), (r\"STRAND (\\d+)\\.\\.(\\d+);\", True)],\n        \"Helix\": [(r\"HELIX (\\d+);\", True), (r\"HELIX (\\d+)\\.\\.(\\d+);\", True)],\n        \"Turn\": [(r\"TURN (\\d+);\", True), (r\"TURN (\\d+)\\.\\.(\\d+);\", True)],\n    }\n\n    UNIPROT_SITE_PATTERNS_RECTIFIED = {\n        \"active_site\": [(r\"ACT_SITE (\\d+);\", False)],\n        \"binding_site\": [\n            (r\"BINDING (\\d+);\", False),\n            (r\"BINDING (\\d+)\\.\\.(\\d+);\", False),\n        ],\n        \"dna_binding\": [\n            (r\"DNA_BIND (\\d+);\", False),\n            (r\"DNA_BIND (\\d+)\\.\\.(\\d+);\", False),\n        ],\n        \"disulfide_bond\": [\n            (r\"DISULFID (\\d+);\", False),\n            (r\"DISULFID (\\d+)\\.\\.(\\d+);\", False),\n        ],\n        \"beta_strand\": [(r\"STRAND (\\d+);\", True), (r\"STRAND (\\d+)\\.\\.(\\d+);\", True)],\n        \"helix\": [(r\"HELIX (\\d+);\", True), (r\"HELIX (\\d+)\\.\\.(\\d+);\", True)],\n        \"turn\": [(r\"TURN (\\d+);\", True), (r\"TURN (\\d+)\\.\\.(\\d+);\", True)],\n    }\n\n    UNIPROT_API_DEFAULT_FIELDS = [\n        \"id\",\n        \"reviewed\",\n        \"protein_name\",\n        \"gene_names\",\n        \"organism_name\",\n        \"length\",\n        \"sequence\",\n        \"ft_act_site\",\n        \"ft_binding\",\n        \"ft_dna_bind\",\n        \"ft_disulfid\",\n        \"ft_strand\",\n        \"ft_helix\",\n        \"ft_turn\",\n    ]\n\n    def __init__(self) -&gt; None:\n        self.data: dict[str, Any] = {}\n        self.pdb_location_relative: str | None = None\n        self.pdb_location_absolute: str | None = None\n\n        self.confidence_data: list[float] | None = None\n        self.sasa_data: structure.sasa.SASAData | None = None\n        self.charge_data: structure.charge.ChargeData | None = None\n        self.cysteine_data: structure.cysteine_data.CysteineData | None = None\n        self.titration_data: structure.titration.TitrationData | None = None\n        pass\n\n    def _rectify_data_labels(self) -&gt; None:\n        \"\"\"\n        Standardize the features names in self.data\n\n        Replaces all spaces with underscores and lowercases the keys\n        \"\"\"\n        for k in list(self.data.keys()):\n            new_key = k.replace(\" \", \"_\").lower()\n            self.data[new_key] = self.data.pop(k)\n\n    @classmethod\n    def from_uniprot_row(cls, row: dict[str, Any]) -&gt; Protein:\n        \"\"\"Create a new Protein object from a row from a Uniprot table\n\n        Args:\n            row (dict[str, Any]): Contains the data from the Uniprot table. Must\n                have \"Sequence\" or \"sequence\" as a key.\n\n        Raises:\n            ValueError: If \"Sequence\" or \"sequence\" is not found in the row.\n\n        Returns:\n            Protein: A processed and standardized protein object.\n        \"\"\"\n        p = cls()\n        if \"Sequence\" in row:\n            p.data[\"sequence\"] = row[\"Sequence\"]\n        elif \"sequence\" in row:\n            p.data[\"sequence\"] = row[\"sequence\"]\n        else:\n            raise ValueError(f\"Sequence not found in row: {row}\")\n\n        for key, value in row.items():\n            if key in cls.UNIPROT_SITE_PATTERNS:\n                p.data[f\"{key}_sites\"] = p._extract_sites(\n                    value,\n                    cls.UNIPROT_SITE_PATTERNS[key],\n                )\n                # p.data[f\"{key}_cysteine_sites\"] = [\n                #     site\n                #     for site in p.data[f\"{key}_sites\"]\n                #     if p._is_site_aa(site, aa=\"C\")\n                # ]\n            else:\n                p.data[key] = value\n\n        p._rectify_data_labels()\n        return p\n\n    @classmethod\n    def from_uniprot_id(\n        cls,\n        uniprot_id: str,\n        fields: list[str] | None = None,\n        from_db: str = \"UniProtKB_AC-ID\",\n        to_db: str = \"UniProtKB-Swiss-Prot\",\n    ) -&gt; Protein:\n        \"\"\"Create a new Protein object from a Uniprot ID (fetches with Uniprot API)\n\n        Args:\n            uniprot_id (str): The Uniprot ID of the protein.\n            fields (list[str] | None, optional): The fields to retrieve from\n                Uniprot. If `None`, `Protein.UNIPROT_API_DEFAULT_FIELDS` is used.\n            from_db (str, optional): The database to retrieve the ID from.\n                Defaults to \"UniProtKB_AC-ID\".\n            to_db (str, optional): The database to map to.\n                Defaults to \"UniProtKB-Swiss-Prot\".\n\n        Raises:\n            ValueError: If we cannot retrieve the Uniprot ID.\n\n        Returns:\n            Protein: A processed and standardized protein object.\n        \"\"\"\n\n        if not fields:\n            fields = cls.UNIPROT_API_DEFAULT_FIELDS\n\n        mapper = ProtMapper()\n\n        result, error = mapper.get(  # type: ignore\n            ids=[uniprot_id], fields=fields, from_db=from_db, to_db=to_db\n        )\n        if error:\n            raise ValueError(f\"Uniprot id not retrieved: {error}\")\n        result.rename(columns={\"From\": \"entry\"}, inplace=True)\n        if \"Length\" in result.columns:\n            result[\"Length\"] = pd.to_numeric(result[\"Length\"])  # type: ignore\n        return cls.from_uniprot_row(result.iloc[0].to_dict())  # type: ignore\n\n    @classmethod\n    def list_from_uniprot_ids(\n        cls,\n        uniprot_ids: list[str],\n        fields: list[str] | None = None,\n        from_db: str = \"UniProtKB_AC-ID\",\n        to_db: str = \"UniProtKB-Swiss-Prot\",\n    ) -&gt; list[Protein]:\n        \"\"\"Create a list of Protein objects from a list of Uniprot IDs (fetches with Uniprot API)\n\n        Args:\n            uniprot_ids (list[str]): The Uniprot IDs of the proteins.\n            fields (list[str] | None, optional): The fields to retrieve from\n                Uniprot. If `None`, `Protein.UNIPROT_API_DEFAULT_FIELDS` is used.\n            from_db (str, optional): The database to retrieve the IDs from.\n                Defaults to \"UniProtKB_AC-ID\".\n            to_db (str, optional): The database to map to.\n                Defaults to \"UniProtKB-Swiss-Prot\".\n\n        Raises:\n            ValueError: If we cannot retrieve the Uniprot IDs.\n\n        Returns:\n            list[Protein]: A list of processed and standardized protein objects.\n        \"\"\"\n        if not fields:\n            fields = cls.UNIPROT_API_DEFAULT_FIELDS\n\n        mapper = ProtMapper()\n\n        result, error = mapper.get(  # type: ignore\n            ids=uniprot_ids, fields=fields, from_db=from_db, to_db=to_db\n        )\n        if error:\n            raise ValueError(f\"Uniprot id not retrieved: {error}\")\n        result.rename(columns={\"From\": \"entry\"}, inplace=True)\n\n        if \"Length\" in result.columns:\n            result[\"Length\"] = pd.to_numeric(result[\"Length\"])  # type: ignore\n        return [cls.from_uniprot_row(row.to_dict()) for _, row in result.iterrows()]  # type: ignore\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Protein):\n            return False\n        return (\n            self.data == other.data\n            and self.sasa_data == other.sasa_data\n            and self.charge_data == other.charge_data\n            and self.cysteine_data == other.cysteine_data\n        )\n\n    def residue_data_frame(self) -&gt; pd.DataFrame:\n        d = dict(\n            chain(\n                self.get_charge().items(),\n                self.get_sasa().items(),\n                self.get_cysteine_data().items(),\n                self.get_titration().items(),\n            )\n        )\n        d[\"pLDDT\"] = self.get_confidence()\n\n        return pd.DataFrame(d)\n\n    def get_confidence(self) -&gt; list[float]:\n        \"\"\"Fetches precomputed confidence data from pdb file.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `confidence_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            list[float]: A list of confidence values for each residue.\n        \"\"\"\n        if self.confidence_data:\n            return self.confidence_data\n\n        if self.pdb_location_absolute:\n            self.confidence_data = structure.confidence.residue_pLDDT(\n                self.pdb_location_absolute,\n            )\n            return self.confidence_data\n        else:\n            raise ValueError(\n                \"Confidence data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_sasa(self) -&gt; structure.sasa.SASAData:\n        \"\"\"Fetches precomputed SASA data for the protein, or computes it.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `sasa_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            structure.sasa.SASAData: A :class:`protein_structure.sasa.SASAData`\n                object containing the SASA values for residues and atoms.\n        \"\"\"\n        if self.sasa_data:\n            return self.sasa_data\n\n        if self.pdb_location_absolute:\n            self.sasa_data = structure.sasa.calculate_sasa(\n                self.pdb_location_absolute,\n            )\n            return self.sasa_data\n        else:\n            raise ValueError(\n                \"SASA data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_charge(self, method=\"gasteiger\") -&gt; structure.charge.ChargeData:\n        \"\"\"Fetches precomputed charge data for the protein, or computes it.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Args:\n            method (str, optional): The method used for the charge calculation.\n                Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to\n                'gasteiger'. For a full list reference\n                https://open-babel.readthedocs.io/en/latest/Charges/charges.html\n\n        Raises:\n            ValueError: If `charge_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            structure.charge.ChargeData: A :class:`protein_structure.charge.ChargeData`\n                object containing the charge values for residues and atoms.\n        \"\"\"\n        if self.charge_data:\n            if self.charge_data[\"charge_method\"]:\n                if self.charge_data[\"charge_method\"][0] == method:\n                    return self.charge_data\n\n        if self.pdb_location_absolute:\n            self.charge_data = structure.charge.calculate_charge(\n                self.pdb_location_absolute,\n                method=method,\n            )\n\n            self.last_charge_method = method\n\n            return self.charge_data\n        else:\n            raise ValueError(\n                \"Charge data for specified method not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_cysteine_data(self) -&gt; structure.cysteine_data.CysteineData:\n        \"\"\"Fetches precomputed size data for the protein, or computes it.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `cysteine_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            structure.size.CysteineData: A :class:`protein_structure.size.CysteineData`\n                object containing the size values for cystein sites.\n        \"\"\"\n        if self.cysteine_data:\n            return self.cysteine_data\n\n        if self.pdb_location_absolute:\n            self.cysteine_data = structure.cysteine_data.calculate_cysteine_data(\n                self.pdb_location_absolute,\n            )\n            return self.cysteine_data\n        else:\n            raise ValueError(\n                \"Size data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_titration(self) -&gt; structure.titration.TitrationData:\n        \"\"\"Runs the default titration calculation for the protein.\n\n        Equivalent to running `self.get_titration_from_propka`.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `titration_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            structure.titration.TitrationData: A\n                :class:`protein_structure.titration.TitrationData` object containing\n                the titration values for residues.\n        \"\"\"\n        return self.get_titration_from_propka()\n\n    def get_titration_from_propka(self) -&gt; structure.titration.TitrationData:\n        \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n        Uses :func:`protein_structure.titration.calculate_titration_propka` if\n        `self.titration_data` is not already stored.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `titration_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            structure.titration.TitrationData: A\n                :class:`protein_structure.titration.TitrationData` object containing\n                the titration values for residues.\"\"\"\n        if self.titration_data:\n            return self.titration_data\n\n        if self.pdb_location_absolute:\n            self.titration_data = structure.titration.calculate_titration_propka(\n                self.pdb_location_absolute,\n            )\n            return self.titration_data\n        else:\n            raise ValueError(\n                \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_titration_from_pypka(self) -&gt; structure.titration.TitrationData:\n        \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n        Uses :func:`protein_structure.titration.calculate_titration_pypka` if\n        `self.titration_data` is not already stored. Requires pypka to be\n        installed, which has dependencies that are not FOSS. Please be sure to\n        verify that you are legally allowed to use pypka.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `titration_data` is not already stored and\n                `pdb_location_absolute` is not set. ImportError: If pypka is not\n                installed.\n\n        Returns:\n            structure.titration.TitrationData: A\n                :class:`protein_structure.titration.TitrationData` object containing\n                the titration values forresidues.\"\"\"\n\n        if self.titration_data:\n            return self.titration_data\n\n        if self.pdb_location_absolute:\n            self.titration_data = structure.titration.calculate_titration_pypka(\n                self.pdb_location_absolute,\n            )\n            return self.titration_data\n        else:\n            raise ValueError(\n                \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_titration_from_pkai(self) -&gt; structure.titration.TitrationData:\n        \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n        Uses :func:`protein_structure.titration.calculate_titration_pkai` if\n        `self.titration_data` is not already stored. Requires pkai to be\n        installed. Note that this method is a deep-learning model, not a\n        physics-based calculation.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `titration_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns: structure.titration.TitrationData: A\n            :class:`protein_structure.titration.TitrationData` object containing\n                the titration values for residues.\"\"\"\n        if self.titration_data:\n            return self.titration_data\n\n        if self.pdb_location_absolute:\n            self.titration_data = structure.titration.calculate_titration_pkai(\n                self.pdb_location_absolute,\n            )\n            return self.titration_data\n        else:\n            raise ValueError(\n                \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def unravel_sites(\n        self,\n        selected_aas: None | set[AminoAcidLetter] = None,\n        selected_keys: None | set[str] = None,\n    ) -&gt; dict[str, list[Any]]:\n        \"\"\"Split the protein into individual sites, recording values for each.\n\n        Args:\n            selected_aas: A set of amino acids letters to include in the output.\n                If `None` (default), all amino acids will be included.\n            selected_keys: A set of keys belonging to this `Protein` object's\n                `data` dictionary to include in the output. If `None` (default),\n                all keys are used.\n\n        Returns:\n            dict[str, list[Any]]: A dictionary mapping keys to lists of values.\n                Each list is a parallel array of the same length as the protein\n                sequence (after filtering out non-selected amino acids).\"\"\"\n        if selected_keys is None:\n            selected_keys = set(self.data.keys()) - {\"sequence\"}\n\n        site_keys = (\n            set(x + \"_sites\" for x in Protein.UNIPROT_SITE_PATTERNS_RECTIFIED.keys())\n            &amp; selected_keys\n        )\n        other_keys = selected_keys - site_keys\n\n        res: dict[str, list[Any]] = {k: [] for k in other_keys}\n        for k in site_keys:\n            res[\"is_\" + k.removesuffix(\"_sites\")] = []  # type: ignore\n        res[\"residue_letter\"] = []\n        res[\"residue_number\"] = []\n\n        for index, site in enumerate(self.data[\"sequence\"]):\n            if selected_aas and site not in selected_aas:\n                continue\n            res[\"residue_letter\"].append(site)\n            res[\"residue_number\"].append(index + 1)\n            for k in site_keys:\n                res[\"is_\" + k.removesuffix(\"_sites\")].append(  # type: ignore\n                    (index + 1) in self.data[k]\n                )\n            for k in other_keys:\n                res[k].append(self.data[k])  # will be the same for all sites\n\n        return res\n\n    def fetch_pdb(self, save_path: str | None = None, url: str | None = None) -&gt; None:\n        \"\"\"Fetches the PDB file for the protein (from the AlphaFold database by default).\n\n        Args:\n            save_path (str | None, optional): The path to save the PDB file to.\n                Defaults to `None`.\n            url (str | None, optional): The URL to fetch the PDB file from.\n                Defaults to `None`, in which case the AlphaFold database is used.\n\n        Raises:\n            Exception: If the response status code is not 200, meaning we could\n                not fetch the PDB from the database.\"\"\"\n        if not url:\n            url = f\"https://alphafold.ebi.ac.uk/files/AF-{self.data['entry']}-F1-model_v4.pdb\"\n        if not save_path:\n            save_path = f\"{self.data['entry']}.pdb\"\n\n        response = requests.get(url)\n\n        if response.status_code != 200:\n            raise Exception(f\"Failed to fetch PDB: {response.status_code}\")\n\n        with open(save_path, \"wb+\") as f:\n            f.write(response.content)\n\n        self.pdb_location_relative = save_path\n        self.pdb_location_absolute = os.path.abspath(save_path)\n\n    def register_local_pdb(self, path_to_pdb_file: str | None = None) -&gt; None:\n        \"\"\"Sets pdb file for protein object using local pdb file.\n\n        Args:\n            path_to_pdb_file (str | None, optional): Path to local PDB file.\n                Defaults to `None`, in which case it assumes a file with 'entry'.pdb.\"\"\"\n        if not path_to_pdb_file:\n            path_to_pdb_file = f\"{self.data['entry']}.pdb\"\n        self.pdb_location_relative = path_to_pdb_file\n        self.pdb_location_absolute = os.path.abspath(path_to_pdb_file)\n\n    def _extract_sites(\n        self, site_description: str, patterns: list[tuple[str, bool]]\n    ) -&gt; list[int]:\n        sites: list[int] = []\n        if (\n            str(site_description) == \"nan\"\n        ):  # this will be the missing value default in pandas--is there a more elegant way to handle this?\n            return sites\n        for pattern, expand_range in patterns:\n            matches = cast(list[str], re.findall(pattern, site_description))\n\n            for match in matches:\n                if isinstance(match, tuple):\n                    start, end = int(match[0]), int(match[1])\n                    if expand_range:\n                        sites.extend(\n                            range(start, end + 1)\n                        )  # Include all values in the range from start to end\n                    else:\n                        sites.extend([start, end])  # Add start and end points\n                else:\n                    sites.append(int(match))\n        return sites\n\n    def _is_site_aa(self, site: int, aa: AminoAcidLetter = \"C\") -&gt; bool:\n        if \"sequence\" not in self.data:\n            raise ValueError(\"Sequence entry not found in data\")\n\n        sequence = self.data[\"sequence\"]\n\n        return site &lt;= len(sequence) and sequence[site - 1] == aa\n</code></pre>"},{"location":"api/#procaliper.Protein.fetch_pdb","title":"<code>fetch_pdb(save_path=None, url=None)</code>","text":"<p>Fetches the PDB file for the protein (from the AlphaFold database by default).</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <code>str | None</code> <p>The path to save the PDB file to. Defaults to <code>None</code>.</p> <code>None</code> <code>url</code> <code>str | None</code> <p>The URL to fetch the PDB file from. Defaults to <code>None</code>, in which case the AlphaFold database is used.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the response status code is not 200, meaning we could not fetch the PDB from the database.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def fetch_pdb(self, save_path: str | None = None, url: str | None = None) -&gt; None:\n    \"\"\"Fetches the PDB file for the protein (from the AlphaFold database by default).\n\n    Args:\n        save_path (str | None, optional): The path to save the PDB file to.\n            Defaults to `None`.\n        url (str | None, optional): The URL to fetch the PDB file from.\n            Defaults to `None`, in which case the AlphaFold database is used.\n\n    Raises:\n        Exception: If the response status code is not 200, meaning we could\n            not fetch the PDB from the database.\"\"\"\n    if not url:\n        url = f\"https://alphafold.ebi.ac.uk/files/AF-{self.data['entry']}-F1-model_v4.pdb\"\n    if not save_path:\n        save_path = f\"{self.data['entry']}.pdb\"\n\n    response = requests.get(url)\n\n    if response.status_code != 200:\n        raise Exception(f\"Failed to fetch PDB: {response.status_code}\")\n\n    with open(save_path, \"wb+\") as f:\n        f.write(response.content)\n\n    self.pdb_location_relative = save_path\n    self.pdb_location_absolute = os.path.abspath(save_path)\n</code></pre>"},{"location":"api/#procaliper.Protein.from_uniprot_id","title":"<code>from_uniprot_id(uniprot_id, fields=None, from_db='UniProtKB_AC-ID', to_db='UniProtKB-Swiss-Prot')</code>  <code>classmethod</code>","text":"<p>Create a new Protein object from a Uniprot ID (fetches with Uniprot API)</p> <p>Parameters:</p> Name Type Description Default <code>uniprot_id</code> <code>str</code> <p>The Uniprot ID of the protein.</p> required <code>fields</code> <code>list[str] | None</code> <p>The fields to retrieve from Uniprot. If <code>None</code>, <code>Protein.UNIPROT_API_DEFAULT_FIELDS</code> is used.</p> <code>None</code> <code>from_db</code> <code>str</code> <p>The database to retrieve the ID from. Defaults to \"UniProtKB_AC-ID\".</p> <code>'UniProtKB_AC-ID'</code> <code>to_db</code> <code>str</code> <p>The database to map to. Defaults to \"UniProtKB-Swiss-Prot\".</p> <code>'UniProtKB-Swiss-Prot'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If we cannot retrieve the Uniprot ID.</p> <p>Returns:</p> Name Type Description <code>Protein</code> <code>Protein</code> <p>A processed and standardized protein object.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>@classmethod\ndef from_uniprot_id(\n    cls,\n    uniprot_id: str,\n    fields: list[str] | None = None,\n    from_db: str = \"UniProtKB_AC-ID\",\n    to_db: str = \"UniProtKB-Swiss-Prot\",\n) -&gt; Protein:\n    \"\"\"Create a new Protein object from a Uniprot ID (fetches with Uniprot API)\n\n    Args:\n        uniprot_id (str): The Uniprot ID of the protein.\n        fields (list[str] | None, optional): The fields to retrieve from\n            Uniprot. If `None`, `Protein.UNIPROT_API_DEFAULT_FIELDS` is used.\n        from_db (str, optional): The database to retrieve the ID from.\n            Defaults to \"UniProtKB_AC-ID\".\n        to_db (str, optional): The database to map to.\n            Defaults to \"UniProtKB-Swiss-Prot\".\n\n    Raises:\n        ValueError: If we cannot retrieve the Uniprot ID.\n\n    Returns:\n        Protein: A processed and standardized protein object.\n    \"\"\"\n\n    if not fields:\n        fields = cls.UNIPROT_API_DEFAULT_FIELDS\n\n    mapper = ProtMapper()\n\n    result, error = mapper.get(  # type: ignore\n        ids=[uniprot_id], fields=fields, from_db=from_db, to_db=to_db\n    )\n    if error:\n        raise ValueError(f\"Uniprot id not retrieved: {error}\")\n    result.rename(columns={\"From\": \"entry\"}, inplace=True)\n    if \"Length\" in result.columns:\n        result[\"Length\"] = pd.to_numeric(result[\"Length\"])  # type: ignore\n    return cls.from_uniprot_row(result.iloc[0].to_dict())  # type: ignore\n</code></pre>"},{"location":"api/#procaliper.Protein.from_uniprot_row","title":"<code>from_uniprot_row(row)</code>  <code>classmethod</code>","text":"<p>Create a new Protein object from a row from a Uniprot table</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>dict[str, Any]</code> <p>Contains the data from the Uniprot table. Must have \"Sequence\" or \"sequence\" as a key.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If \"Sequence\" or \"sequence\" is not found in the row.</p> <p>Returns:</p> Name Type Description <code>Protein</code> <code>Protein</code> <p>A processed and standardized protein object.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>@classmethod\ndef from_uniprot_row(cls, row: dict[str, Any]) -&gt; Protein:\n    \"\"\"Create a new Protein object from a row from a Uniprot table\n\n    Args:\n        row (dict[str, Any]): Contains the data from the Uniprot table. Must\n            have \"Sequence\" or \"sequence\" as a key.\n\n    Raises:\n        ValueError: If \"Sequence\" or \"sequence\" is not found in the row.\n\n    Returns:\n        Protein: A processed and standardized protein object.\n    \"\"\"\n    p = cls()\n    if \"Sequence\" in row:\n        p.data[\"sequence\"] = row[\"Sequence\"]\n    elif \"sequence\" in row:\n        p.data[\"sequence\"] = row[\"sequence\"]\n    else:\n        raise ValueError(f\"Sequence not found in row: {row}\")\n\n    for key, value in row.items():\n        if key in cls.UNIPROT_SITE_PATTERNS:\n            p.data[f\"{key}_sites\"] = p._extract_sites(\n                value,\n                cls.UNIPROT_SITE_PATTERNS[key],\n            )\n            # p.data[f\"{key}_cysteine_sites\"] = [\n            #     site\n            #     for site in p.data[f\"{key}_sites\"]\n            #     if p._is_site_aa(site, aa=\"C\")\n            # ]\n        else:\n            p.data[key] = value\n\n    p._rectify_data_labels()\n    return p\n</code></pre>"},{"location":"api/#procaliper.Protein.get_charge","title":"<code>get_charge(method='gasteiger')</code>","text":"<p>Fetches precomputed charge data for the protein, or computes it.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The method used for the charge calculation. Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to 'gasteiger'. For a full list reference https://open-babel.readthedocs.io/en/latest/Charges/charges.html</p> <code>'gasteiger'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>charge_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>ChargeData</code> <p>structure.charge.ChargeData: A :class:<code>protein_structure.charge.ChargeData</code> object containing the charge values for residues and atoms.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_charge(self, method=\"gasteiger\") -&gt; structure.charge.ChargeData:\n    \"\"\"Fetches precomputed charge data for the protein, or computes it.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Args:\n        method (str, optional): The method used for the charge calculation.\n            Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to\n            'gasteiger'. For a full list reference\n            https://open-babel.readthedocs.io/en/latest/Charges/charges.html\n\n    Raises:\n        ValueError: If `charge_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        structure.charge.ChargeData: A :class:`protein_structure.charge.ChargeData`\n            object containing the charge values for residues and atoms.\n    \"\"\"\n    if self.charge_data:\n        if self.charge_data[\"charge_method\"]:\n            if self.charge_data[\"charge_method\"][0] == method:\n                return self.charge_data\n\n    if self.pdb_location_absolute:\n        self.charge_data = structure.charge.calculate_charge(\n            self.pdb_location_absolute,\n            method=method,\n        )\n\n        self.last_charge_method = method\n\n        return self.charge_data\n    else:\n        raise ValueError(\n            \"Charge data for specified method not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_confidence","title":"<code>get_confidence()</code>","text":"<p>Fetches precomputed confidence data from pdb file.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>confidence_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: A list of confidence values for each residue.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_confidence(self) -&gt; list[float]:\n    \"\"\"Fetches precomputed confidence data from pdb file.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `confidence_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        list[float]: A list of confidence values for each residue.\n    \"\"\"\n    if self.confidence_data:\n        return self.confidence_data\n\n    if self.pdb_location_absolute:\n        self.confidence_data = structure.confidence.residue_pLDDT(\n            self.pdb_location_absolute,\n        )\n        return self.confidence_data\n    else:\n        raise ValueError(\n            \"Confidence data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_cysteine_data","title":"<code>get_cysteine_data()</code>","text":"<p>Fetches precomputed size data for the protein, or computes it.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>cysteine_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>CysteineData</code> <p>structure.size.CysteineData: A :class:<code>protein_structure.size.CysteineData</code> object containing the size values for cystein sites.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_cysteine_data(self) -&gt; structure.cysteine_data.CysteineData:\n    \"\"\"Fetches precomputed size data for the protein, or computes it.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `cysteine_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        structure.size.CysteineData: A :class:`protein_structure.size.CysteineData`\n            object containing the size values for cystein sites.\n    \"\"\"\n    if self.cysteine_data:\n        return self.cysteine_data\n\n    if self.pdb_location_absolute:\n        self.cysteine_data = structure.cysteine_data.calculate_cysteine_data(\n            self.pdb_location_absolute,\n        )\n        return self.cysteine_data\n    else:\n        raise ValueError(\n            \"Size data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_sasa","title":"<code>get_sasa()</code>","text":"<p>Fetches precomputed SASA data for the protein, or computes it.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>sasa_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>SASAData</code> <p>structure.sasa.SASAData: A :class:<code>protein_structure.sasa.SASAData</code> object containing the SASA values for residues and atoms.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_sasa(self) -&gt; structure.sasa.SASAData:\n    \"\"\"Fetches precomputed SASA data for the protein, or computes it.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `sasa_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        structure.sasa.SASAData: A :class:`protein_structure.sasa.SASAData`\n            object containing the SASA values for residues and atoms.\n    \"\"\"\n    if self.sasa_data:\n        return self.sasa_data\n\n    if self.pdb_location_absolute:\n        self.sasa_data = structure.sasa.calculate_sasa(\n            self.pdb_location_absolute,\n        )\n        return self.sasa_data\n    else:\n        raise ValueError(\n            \"SASA data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_titration","title":"<code>get_titration()</code>","text":"<p>Runs the default titration calculation for the protein.</p> <p>Equivalent to running <code>self.get_titration_from_propka</code>.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>titration_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>TitrationData</code> <p>structure.titration.TitrationData: A :class:<code>protein_structure.titration.TitrationData</code> object containing the titration values for residues.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_titration(self) -&gt; structure.titration.TitrationData:\n    \"\"\"Runs the default titration calculation for the protein.\n\n    Equivalent to running `self.get_titration_from_propka`.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `titration_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        structure.titration.TitrationData: A\n            :class:`protein_structure.titration.TitrationData` object containing\n            the titration values for residues.\n    \"\"\"\n    return self.get_titration_from_propka()\n</code></pre>"},{"location":"api/#procaliper.Protein.get_titration_from_pkai","title":"<code>get_titration_from_pkai()</code>","text":"<p>Fetches precomputed titration data for the protein, or computes it.</p> <p>Uses :func:<code>protein_structure.titration.calculate_titration_pkai</code> if <code>self.titration_data</code> is not already stored. Requires pkai to be installed. Note that this method is a deep-learning model, not a physics-based calculation.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>titration_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>structure.titration.TitrationData: A</p> Type Description <code>TitrationData</code> <p>the titration values for residues.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_titration_from_pkai(self) -&gt; structure.titration.TitrationData:\n    \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n    Uses :func:`protein_structure.titration.calculate_titration_pkai` if\n    `self.titration_data` is not already stored. Requires pkai to be\n    installed. Note that this method is a deep-learning model, not a\n    physics-based calculation.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `titration_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns: structure.titration.TitrationData: A\n        :class:`protein_structure.titration.TitrationData` object containing\n            the titration values for residues.\"\"\"\n    if self.titration_data:\n        return self.titration_data\n\n    if self.pdb_location_absolute:\n        self.titration_data = structure.titration.calculate_titration_pkai(\n            self.pdb_location_absolute,\n        )\n        return self.titration_data\n    else:\n        raise ValueError(\n            \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_titration_from_propka","title":"<code>get_titration_from_propka()</code>","text":"<p>Fetches precomputed titration data for the protein, or computes it.</p> <p>Uses :func:<code>protein_structure.titration.calculate_titration_propka</code> if <code>self.titration_data</code> is not already stored.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>titration_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>TitrationData</code> <p>structure.titration.TitrationData: A :class:<code>protein_structure.titration.TitrationData</code> object containing the titration values for residues.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_titration_from_propka(self) -&gt; structure.titration.TitrationData:\n    \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n    Uses :func:`protein_structure.titration.calculate_titration_propka` if\n    `self.titration_data` is not already stored.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `titration_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        structure.titration.TitrationData: A\n            :class:`protein_structure.titration.TitrationData` object containing\n            the titration values for residues.\"\"\"\n    if self.titration_data:\n        return self.titration_data\n\n    if self.pdb_location_absolute:\n        self.titration_data = structure.titration.calculate_titration_propka(\n            self.pdb_location_absolute,\n        )\n        return self.titration_data\n    else:\n        raise ValueError(\n            \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_titration_from_pypka","title":"<code>get_titration_from_pypka()</code>","text":"<p>Fetches precomputed titration data for the protein, or computes it.</p> <p>Uses :func:<code>protein_structure.titration.calculate_titration_pypka</code> if <code>self.titration_data</code> is not already stored. Requires pypka to be installed, which has dependencies that are not FOSS. Please be sure to verify that you are legally allowed to use pypka.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>titration_data</code> is not already stored and <code>pdb_location_absolute</code> is not set. ImportError: If pypka is not installed.</p> <p>Returns:</p> Type Description <code>TitrationData</code> <p>structure.titration.TitrationData: A :class:<code>protein_structure.titration.TitrationData</code> object containing the titration values forresidues.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_titration_from_pypka(self) -&gt; structure.titration.TitrationData:\n    \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n    Uses :func:`protein_structure.titration.calculate_titration_pypka` if\n    `self.titration_data` is not already stored. Requires pypka to be\n    installed, which has dependencies that are not FOSS. Please be sure to\n    verify that you are legally allowed to use pypka.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `titration_data` is not already stored and\n            `pdb_location_absolute` is not set. ImportError: If pypka is not\n            installed.\n\n    Returns:\n        structure.titration.TitrationData: A\n            :class:`protein_structure.titration.TitrationData` object containing\n            the titration values forresidues.\"\"\"\n\n    if self.titration_data:\n        return self.titration_data\n\n    if self.pdb_location_absolute:\n        self.titration_data = structure.titration.calculate_titration_pypka(\n            self.pdb_location_absolute,\n        )\n        return self.titration_data\n    else:\n        raise ValueError(\n            \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.list_from_uniprot_ids","title":"<code>list_from_uniprot_ids(uniprot_ids, fields=None, from_db='UniProtKB_AC-ID', to_db='UniProtKB-Swiss-Prot')</code>  <code>classmethod</code>","text":"<p>Create a list of Protein objects from a list of Uniprot IDs (fetches with Uniprot API)</p> <p>Parameters:</p> Name Type Description Default <code>uniprot_ids</code> <code>list[str]</code> <p>The Uniprot IDs of the proteins.</p> required <code>fields</code> <code>list[str] | None</code> <p>The fields to retrieve from Uniprot. If <code>None</code>, <code>Protein.UNIPROT_API_DEFAULT_FIELDS</code> is used.</p> <code>None</code> <code>from_db</code> <code>str</code> <p>The database to retrieve the IDs from. Defaults to \"UniProtKB_AC-ID\".</p> <code>'UniProtKB_AC-ID'</code> <code>to_db</code> <code>str</code> <p>The database to map to. Defaults to \"UniProtKB-Swiss-Prot\".</p> <code>'UniProtKB-Swiss-Prot'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If we cannot retrieve the Uniprot IDs.</p> <p>Returns:</p> Type Description <code>list[Protein]</code> <p>list[Protein]: A list of processed and standardized protein objects.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>@classmethod\ndef list_from_uniprot_ids(\n    cls,\n    uniprot_ids: list[str],\n    fields: list[str] | None = None,\n    from_db: str = \"UniProtKB_AC-ID\",\n    to_db: str = \"UniProtKB-Swiss-Prot\",\n) -&gt; list[Protein]:\n    \"\"\"Create a list of Protein objects from a list of Uniprot IDs (fetches with Uniprot API)\n\n    Args:\n        uniprot_ids (list[str]): The Uniprot IDs of the proteins.\n        fields (list[str] | None, optional): The fields to retrieve from\n            Uniprot. If `None`, `Protein.UNIPROT_API_DEFAULT_FIELDS` is used.\n        from_db (str, optional): The database to retrieve the IDs from.\n            Defaults to \"UniProtKB_AC-ID\".\n        to_db (str, optional): The database to map to.\n            Defaults to \"UniProtKB-Swiss-Prot\".\n\n    Raises:\n        ValueError: If we cannot retrieve the Uniprot IDs.\n\n    Returns:\n        list[Protein]: A list of processed and standardized protein objects.\n    \"\"\"\n    if not fields:\n        fields = cls.UNIPROT_API_DEFAULT_FIELDS\n\n    mapper = ProtMapper()\n\n    result, error = mapper.get(  # type: ignore\n        ids=uniprot_ids, fields=fields, from_db=from_db, to_db=to_db\n    )\n    if error:\n        raise ValueError(f\"Uniprot id not retrieved: {error}\")\n    result.rename(columns={\"From\": \"entry\"}, inplace=True)\n\n    if \"Length\" in result.columns:\n        result[\"Length\"] = pd.to_numeric(result[\"Length\"])  # type: ignore\n    return [cls.from_uniprot_row(row.to_dict()) for _, row in result.iterrows()]  # type: ignore\n</code></pre>"},{"location":"api/#procaliper.Protein.register_local_pdb","title":"<code>register_local_pdb(path_to_pdb_file=None)</code>","text":"<p>Sets pdb file for protein object using local pdb file.</p> <p>Parameters:</p> Name Type Description Default <code>path_to_pdb_file</code> <code>str | None</code> <p>Path to local PDB file. Defaults to <code>None</code>, in which case it assumes a file with 'entry'.pdb.</p> <code>None</code> Source code in <code>procaliper/_protein.py</code> <pre><code>def register_local_pdb(self, path_to_pdb_file: str | None = None) -&gt; None:\n    \"\"\"Sets pdb file for protein object using local pdb file.\n\n    Args:\n        path_to_pdb_file (str | None, optional): Path to local PDB file.\n            Defaults to `None`, in which case it assumes a file with 'entry'.pdb.\"\"\"\n    if not path_to_pdb_file:\n        path_to_pdb_file = f\"{self.data['entry']}.pdb\"\n    self.pdb_location_relative = path_to_pdb_file\n    self.pdb_location_absolute = os.path.abspath(path_to_pdb_file)\n</code></pre>"},{"location":"api/#procaliper.Protein.unravel_sites","title":"<code>unravel_sites(selected_aas=None, selected_keys=None)</code>","text":"<p>Split the protein into individual sites, recording values for each.</p> <p>Parameters:</p> Name Type Description Default <code>selected_aas</code> <code>None | set[AminoAcidLetter]</code> <p>A set of amino acids letters to include in the output. If <code>None</code> (default), all amino acids will be included.</p> <code>None</code> <code>selected_keys</code> <code>None | set[str]</code> <p>A set of keys belonging to this <code>Protein</code> object's <code>data</code> dictionary to include in the output. If <code>None</code> (default), all keys are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, list[Any]]</code> <p>dict[str, list[Any]]: A dictionary mapping keys to lists of values. Each list is a parallel array of the same length as the protein sequence (after filtering out non-selected amino acids).</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def unravel_sites(\n    self,\n    selected_aas: None | set[AminoAcidLetter] = None,\n    selected_keys: None | set[str] = None,\n) -&gt; dict[str, list[Any]]:\n    \"\"\"Split the protein into individual sites, recording values for each.\n\n    Args:\n        selected_aas: A set of amino acids letters to include in the output.\n            If `None` (default), all amino acids will be included.\n        selected_keys: A set of keys belonging to this `Protein` object's\n            `data` dictionary to include in the output. If `None` (default),\n            all keys are used.\n\n    Returns:\n        dict[str, list[Any]]: A dictionary mapping keys to lists of values.\n            Each list is a parallel array of the same length as the protein\n            sequence (after filtering out non-selected amino acids).\"\"\"\n    if selected_keys is None:\n        selected_keys = set(self.data.keys()) - {\"sequence\"}\n\n    site_keys = (\n        set(x + \"_sites\" for x in Protein.UNIPROT_SITE_PATTERNS_RECTIFIED.keys())\n        &amp; selected_keys\n    )\n    other_keys = selected_keys - site_keys\n\n    res: dict[str, list[Any]] = {k: [] for k in other_keys}\n    for k in site_keys:\n        res[\"is_\" + k.removesuffix(\"_sites\")] = []  # type: ignore\n    res[\"residue_letter\"] = []\n    res[\"residue_number\"] = []\n\n    for index, site in enumerate(self.data[\"sequence\"]):\n        if selected_aas and site not in selected_aas:\n            continue\n        res[\"residue_letter\"].append(site)\n        res[\"residue_number\"].append(index + 1)\n        for k in site_keys:\n            res[\"is_\" + k.removesuffix(\"_sites\")].append(  # type: ignore\n                (index + 1) in self.data[k]\n            )\n        for k in other_keys:\n            res[k].append(self.data[k])  # will be the same for all sites\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.app","title":"<code>app</code>","text":"<p>Main module.</p>"},{"location":"api/#procaliper.cli","title":"<code>cli</code>","text":"<p>Console script for procaliper.</p>"},{"location":"api/#procaliper.protein_structure","title":"<code>protein_structure</code>","text":""},{"location":"api/#procaliper.protein_structure.calculate_charge","title":"<code>calculate_charge(pdb_filename, method='gasteiger')</code>","text":"<p>Computes the charge of CYS sites in a PDB file.</p> <p>By default, the method used is 'gasteiger', but this is configurable in <code>hyperparameters.py</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file. shortname (str): The shortname of the protein (typically will be UniProt ID).</p> required <code>method</code> <code>str</code> <p>The method used for the charge calculation. Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to 'gasteiger'. For a full list reference https://open-babel.readthedocs.io/en/latest/Charges/charges.html</p> <code>'gasteiger'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the charge method is not found.</p> <p>Returns:</p> Name Type Description <code>ChargeData</code> <code>ChargeData</code> <p>A data class for holding charge data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/charge.py</code> <pre><code>def calculate_charge(pdb_filename: str, method=\"gasteiger\") -&gt; ChargeData:\n    \"\"\"Computes the charge of CYS sites in a PDB file.\n\n    By default, the method used is 'gasteiger', but this is configurable in\n    `hyperparameters.py`.\n\n    Args:\n        pdb_filename (str): The path to the PDB file. shortname (str): The\n            shortname of the protein (typically will be UniProt ID).\n        method (str, optional): The method used for the charge calculation.\n            Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to\n            'gasteiger'. For a full list reference\n            https://open-babel.readthedocs.io/en/latest/Charges/charges.html\n\n\n    Raises:\n        ValueError: If the charge method is not found.\n\n    Returns:\n        ChargeData: A data class for holding charge data from computed from a\n            PDB file.\n    \"\"\"\n    pbmol = next(pybel.readfile(\"pdb\", pdb_filename))  # type: ignore\n    mol = pbmol.OBMol  # type: ignore\n\n    # Applies the model and computes charges.\n    ob_charge_model = ob.OBChargeModel.FindType(method)  # type: ignore\n\n    if not ob_charge_model:  # type: ignore\n        raise ValueError(\"Charge method not found. Please check hyperparameters.py\")\n    ob_charge_model.ComputeCharges(mol)  # type: ignore\n\n    charges = cast(list[float], ob_charge_model.GetPartialCharges())  # type: ignore\n\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)  # type: ignore\n\n    # Set up dict\n    res = ChargeData(\n        {\n            \"charge\": [],\n            \"charge_method\": [],\n            \"residue_number\": [],\n            \"residue_name\": [],\n        }\n    )\n\n    for res_num, residue in ppdb.df[\"ATOM\"].groupby(\"residue_number\"):\n        res[\"charge\"].append([charges[x - 1] for x in sorted(residue[\"atom_number\"])])\n        res[\"charge_method\"].append(method)\n        res[\"residue_number\"].append(int(res_num))\n        res[\"residue_name\"].append(\n            residue[\"residue_name\"].iloc[0]\n        )  # all residue names should be the same because these atoms are from the same residue\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.calculate_cysteine_data","title":"<code>calculate_cysteine_data(pdb_filename)</code>","text":"<p>Calculates spatial data for a protein from a PDB file.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Name Type Description <code>CysteineData</code> <code>CysteineData</code> <p>A data class for holding size data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/cysteine_data.py</code> <pre><code>def calculate_cysteine_data(pdb_filename: str) -&gt; CysteineData:\n    \"\"\"Calculates spatial data for a protein from a PDB file.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        CysteineData: A data class for holding size data from computed from a PDB file.\n    \"\"\"\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)  # type: ignore\n\n    res = CysteineData(\n        {\n            \"cys_ratio\": [],\n            \"min_dist_to_closest_sulfur\": [],\n            \"sulfur_closeness_rating_scaled\": [],\n            \"residue_id\": [],\n            \"residue_name\": [],\n        }\n    )\n\n    total_residue = cast(int, max(ppdb.df[\"ATOM\"][\"residue_number\"]))  # type: ignore\n\n    cys_positions: list[tuple[float, float, float]] = []\n    for x in range(len(ppdb.df[\"ATOM\"])):  # type: ignore\n        if ppdb.df[\"ATOM\"][\"residue_name\"][x] == \"CYS\":  # type: ignore\n            if ppdb.df[\"ATOM\"][\"atom_name\"][x] == \"SG\":  # type: ignore\n                cys_positions.append(\n                    (\n                        ppdb.df[\"ATOM\"][\"x_coord\"][x],  # type: ignore\n                        ppdb.df[\"ATOM\"][\"y_coord\"][x],  # type: ignore\n                        ppdb.df[\"ATOM\"][\"z_coord\"][x],  # type: ignore\n                    )\n                )\n    total_cys_sites = len(cys_positions)\n\n    cys_index = 0\n\n    for _, grp in ppdb.df[\"ATOM\"].groupby(\"residue_number\"):  # type: ignore\n        res[\"residue_id\"].append(grp[\"residue_number\"].max())\n        res[\"residue_name\"].append(grp[\"residue_name\"].max())\n\n        if grp[\"residue_name\"].max() == \"CYS\":  # type: ignore\n            sg_closeness_rating_scaled = 0\n            x_p, y_p, z_p = cys_positions[cys_index]\n            min_distance = 1000  # Initialize with a large number\n\n            points_excluding_index = (\n                cys_positions[:cys_index] + cys_positions[cys_index + 1 :]\n            )\n            for point in points_excluding_index:\n                x_q, y_q, z_q = point\n                distance = np.sqrt(\n                    (x_p - x_q) ** 2 + (y_p - y_q) ** 2 + (z_p - z_q) ** 2\n                )\n                if distance &lt; min_distance:\n                    min_distance = distance\n                sg_closeness_rating_scaled += 10 / ((distance + 1) ** 2)\n\n            cys_index += 1\n\n            res[\"cys_ratio\"].append(float(total_cys_sites) / float(total_residue))\n            res[\"min_dist_to_closest_sulfur\"].append(min_distance)\n            res[\"sulfur_closeness_rating_scaled\"].append(sg_closeness_rating_scaled)\n        else:\n            res[\"cys_ratio\"].append(None)\n            res[\"min_dist_to_closest_sulfur\"].append(None)\n            res[\"sulfur_closeness_rating_scaled\"].append(None)\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.calculate_sasa","title":"<code>calculate_sasa(pdb_filename)</code>","text":"<p>Compute the SASA values for all CYS sites in a PDB file.</p> <p>Uses the ShrakeRupley algorithm implemented in <code>Bio.PDB.SASA.ShrakeRupley</code> with a probe radius of 1.40 and 100 points.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Name Type Description <code>SASAData</code> <code>SASAData</code> <p>A data class for holding SASA data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/sasa.py</code> <pre><code>def calculate_sasa(pdb_filename: str) -&gt; SASAData:\n    \"\"\"Compute the SASA values for all CYS sites in a PDB file.\n\n    Uses the ShrakeRupley algorithm implemented in `Bio.PDB.SASA.ShrakeRupley`\n    with a probe radius of 1.40 and 100 points.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        SASAData: A data class for holding SASA data from computed from a PDB\n            file.\"\"\"\n    p = PDBParser(QUIET=True)\n    struct = p.get_structure(\"\", pdb_filename)  # type: ignore\n\n    sr = ShrakeRupley(probe_radius=PROBE_RADIUS, n_points=N_POINTS, radii_dict=None)\n\n    # Calc sasa values from Residues (from atoms)\n    sr.compute(struct, level=\"R\")  # type: ignore\n\n    # Set up dict\n    res = SASAData(\n        {\n            \"all_sasa_value\": [],\n            \"atom_sasa_values\": [],\n            \"residue_number\": [],\n            \"residue_name\": [],\n        }\n    )\n\n    # Fill dict with CYS sites\n    for x in struct.child_list:  # type: ignore\n        for y in x.child_list:  # type: ignore\n            for z in y.child_list:  # type: ignore\n                res[\"all_sasa_value\"].append(z.sasa)  # type: ignore\n                res[\"atom_sasa_values\"].append([x.sasa for x in z.child_list])  # type: ignore\n                res[\"residue_number\"].append(int(z.id[1]))  # type: ignore\n                res[\"residue_name\"].append(z.resname)  # type: ignore\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.residue_pLDDT","title":"<code>residue_pLDDT(pdb_filename)</code>","text":"<p>Extracts the pLDDT confidence for each residue in a PDB file.</p> <p>We assume that the pLDDT confidences are in the B-factor entries of the PDB file. If this information is provided at the atom-level, the maximimum value across the residue is used.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: The pLDDT confidence for each residue in the PDB file.</p> Source code in <code>procaliper/protein_structure/confidence.py</code> <pre><code>def residue_pLDDT(pdb_filename: str) -&gt; list[float]:\n    \"\"\"Extracts the pLDDT confidence for each residue in a PDB file.\n\n    We assume that the pLDDT confidences are in the B-factor entries of the PDB\n    file. If this information is provided at the atom-level, the maximimum value\n    across the residue is used.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        list[float]: The pLDDT confidence for each residue in the PDB file.\n    \"\"\"\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)  # type: ignore\n\n    vals = []\n    for _, res in ppdb.df[\"ATOM\"].groupby(\"residue_number\"):  # type: ignore\n        vals.append(res[\"b_factor\"].max())\n\n    return vals\n</code></pre>"},{"location":"api/#procaliper.protein_structure.charge","title":"<code>charge</code>","text":""},{"location":"api/#procaliper.protein_structure.charge.ChargeData","title":"<code>ChargeData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>A data class for holding charge data from computed from a PDB file.</p> <p>Attributes:</p> Name Type Description <code>charges</code> <code>list[list[float]]</code> <p>The charge value for atoms in the residue, ordered from C-terminus to N-terminus according to standard pdb order. For example, in CYS, the last atom is always the SG sulfur.</p> <code>method</code> <code>list[str]</code> <p>The method used for the charge calculation.</p> <code>residue_number</code> <code>list[int]</code> <p>The residue number for the site.</p> <code>residue_name</code> <code>list[str]</code> <p>The residue name (three-letter amino acid abbreviation) for the sites.</p> Source code in <code>procaliper/protein_structure/charge.py</code> <pre><code>class ChargeData(TypedDict):\n    \"\"\"\n    A data class for holding charge data from computed from a PDB file.\n\n    Attributes:\n        charges (list[list[float]]): The charge value for atoms in the residue,\n            ordered from C-terminus to N-terminus according to standard pdb order.\n            For example, in CYS, the last atom is always the SG sulfur.\n        method (list[str]): The method used for the charge calculation.\n        residue_number (list[int]): The residue number for the site.\n        residue_name (list[str]): The residue name (three-letter amino acid\n            abbreviation) for the sites.\n    \"\"\"\n\n    charge: list[list[float]]\n    charge_method: list[str]\n    residue_number: list[int]\n    residue_name: list[str]\n</code></pre>"},{"location":"api/#procaliper.protein_structure.charge.calculate_charge","title":"<code>calculate_charge(pdb_filename, method='gasteiger')</code>","text":"<p>Computes the charge of CYS sites in a PDB file.</p> <p>By default, the method used is 'gasteiger', but this is configurable in <code>hyperparameters.py</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file. shortname (str): The shortname of the protein (typically will be UniProt ID).</p> required <code>method</code> <code>str</code> <p>The method used for the charge calculation. Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to 'gasteiger'. For a full list reference https://open-babel.readthedocs.io/en/latest/Charges/charges.html</p> <code>'gasteiger'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the charge method is not found.</p> <p>Returns:</p> Name Type Description <code>ChargeData</code> <code>ChargeData</code> <p>A data class for holding charge data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/charge.py</code> <pre><code>def calculate_charge(pdb_filename: str, method=\"gasteiger\") -&gt; ChargeData:\n    \"\"\"Computes the charge of CYS sites in a PDB file.\n\n    By default, the method used is 'gasteiger', but this is configurable in\n    `hyperparameters.py`.\n\n    Args:\n        pdb_filename (str): The path to the PDB file. shortname (str): The\n            shortname of the protein (typically will be UniProt ID).\n        method (str, optional): The method used for the charge calculation.\n            Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to\n            'gasteiger'. For a full list reference\n            https://open-babel.readthedocs.io/en/latest/Charges/charges.html\n\n\n    Raises:\n        ValueError: If the charge method is not found.\n\n    Returns:\n        ChargeData: A data class for holding charge data from computed from a\n            PDB file.\n    \"\"\"\n    pbmol = next(pybel.readfile(\"pdb\", pdb_filename))  # type: ignore\n    mol = pbmol.OBMol  # type: ignore\n\n    # Applies the model and computes charges.\n    ob_charge_model = ob.OBChargeModel.FindType(method)  # type: ignore\n\n    if not ob_charge_model:  # type: ignore\n        raise ValueError(\"Charge method not found. Please check hyperparameters.py\")\n    ob_charge_model.ComputeCharges(mol)  # type: ignore\n\n    charges = cast(list[float], ob_charge_model.GetPartialCharges())  # type: ignore\n\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)  # type: ignore\n\n    # Set up dict\n    res = ChargeData(\n        {\n            \"charge\": [],\n            \"charge_method\": [],\n            \"residue_number\": [],\n            \"residue_name\": [],\n        }\n    )\n\n    for res_num, residue in ppdb.df[\"ATOM\"].groupby(\"residue_number\"):\n        res[\"charge\"].append([charges[x - 1] for x in sorted(residue[\"atom_number\"])])\n        res[\"charge_method\"].append(method)\n        res[\"residue_number\"].append(int(res_num))\n        res[\"residue_name\"].append(\n            residue[\"residue_name\"].iloc[0]\n        )  # all residue names should be the same because these atoms are from the same residue\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.confidence","title":"<code>confidence</code>","text":""},{"location":"api/#procaliper.protein_structure.confidence.residue_pLDDT","title":"<code>residue_pLDDT(pdb_filename)</code>","text":"<p>Extracts the pLDDT confidence for each residue in a PDB file.</p> <p>We assume that the pLDDT confidences are in the B-factor entries of the PDB file. If this information is provided at the atom-level, the maximimum value across the residue is used.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: The pLDDT confidence for each residue in the PDB file.</p> Source code in <code>procaliper/protein_structure/confidence.py</code> <pre><code>def residue_pLDDT(pdb_filename: str) -&gt; list[float]:\n    \"\"\"Extracts the pLDDT confidence for each residue in a PDB file.\n\n    We assume that the pLDDT confidences are in the B-factor entries of the PDB\n    file. If this information is provided at the atom-level, the maximimum value\n    across the residue is used.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        list[float]: The pLDDT confidence for each residue in the PDB file.\n    \"\"\"\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)  # type: ignore\n\n    vals = []\n    for _, res in ppdb.df[\"ATOM\"].groupby(\"residue_number\"):  # type: ignore\n        vals.append(res[\"b_factor\"].max())\n\n    return vals\n</code></pre>"},{"location":"api/#procaliper.protein_structure.cysteine_data","title":"<code>cysteine_data</code>","text":""},{"location":"api/#procaliper.protein_structure.cysteine_data.CysteineData","title":"<code>CysteineData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Data class for holding size data from computed from a PDB file.</p> <p>Non-CYS sites are assigned <code>None</code> values.</p> <p>Attributes:</p> Name Type Description <code>cys_ratio</code> <code>list[float | None]</code> <p>The ratio of CYS sites to total sites.</p> <code>min_dist_to_closest_sulfur</code> <code>list[float | None]</code> <p>The minimum distance to the closest sulfur for each CYS site.</p> <code>sulfur_closeness_rating_scaled</code> <code>list[float | None]</code> <p>The sulfur closeness rating scaled for the CYS sites.</p> <code>residue_id</code> <code>list[int | None]</code> <p>The residue ID for the CYS sites.</p> <code>residue_name</code> <code>list[str | None]</code> <p>The residue name for the CYS sites.</p> Source code in <code>procaliper/protein_structure/cysteine_data.py</code> <pre><code>class CysteineData(TypedDict):\n    \"\"\"Data class for holding size data from computed from a PDB file.\n\n    Non-CYS sites are assigned `None` values.\n\n    Attributes:\n        cys_ratio (list[float | None]): The ratio of CYS sites to total sites.\n        min_dist_to_closest_sulfur (list[float | None]): The minimum distance to the closest sulfur for each CYS site.\n        sulfur_closeness_rating_scaled (list[float | None]): The sulfur closeness rating scaled for the CYS sites.\n        residue_id (list[int | None]): The residue ID for the CYS sites.\n        residue_name (list[str | None]): The residue name for the CYS sites.\"\"\"\n\n    cys_ratio: list[float | None]\n    min_dist_to_closest_sulfur: list[float | None]\n    sulfur_closeness_rating_scaled: list[float | None]\n    residue_id: list[int | None]\n    residue_name: list[str | None]\n</code></pre>"},{"location":"api/#procaliper.protein_structure.cysteine_data.calculate_cysteine_data","title":"<code>calculate_cysteine_data(pdb_filename)</code>","text":"<p>Calculates spatial data for a protein from a PDB file.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Name Type Description <code>CysteineData</code> <code>CysteineData</code> <p>A data class for holding size data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/cysteine_data.py</code> <pre><code>def calculate_cysteine_data(pdb_filename: str) -&gt; CysteineData:\n    \"\"\"Calculates spatial data for a protein from a PDB file.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        CysteineData: A data class for holding size data from computed from a PDB file.\n    \"\"\"\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)  # type: ignore\n\n    res = CysteineData(\n        {\n            \"cys_ratio\": [],\n            \"min_dist_to_closest_sulfur\": [],\n            \"sulfur_closeness_rating_scaled\": [],\n            \"residue_id\": [],\n            \"residue_name\": [],\n        }\n    )\n\n    total_residue = cast(int, max(ppdb.df[\"ATOM\"][\"residue_number\"]))  # type: ignore\n\n    cys_positions: list[tuple[float, float, float]] = []\n    for x in range(len(ppdb.df[\"ATOM\"])):  # type: ignore\n        if ppdb.df[\"ATOM\"][\"residue_name\"][x] == \"CYS\":  # type: ignore\n            if ppdb.df[\"ATOM\"][\"atom_name\"][x] == \"SG\":  # type: ignore\n                cys_positions.append(\n                    (\n                        ppdb.df[\"ATOM\"][\"x_coord\"][x],  # type: ignore\n                        ppdb.df[\"ATOM\"][\"y_coord\"][x],  # type: ignore\n                        ppdb.df[\"ATOM\"][\"z_coord\"][x],  # type: ignore\n                    )\n                )\n    total_cys_sites = len(cys_positions)\n\n    cys_index = 0\n\n    for _, grp in ppdb.df[\"ATOM\"].groupby(\"residue_number\"):  # type: ignore\n        res[\"residue_id\"].append(grp[\"residue_number\"].max())\n        res[\"residue_name\"].append(grp[\"residue_name\"].max())\n\n        if grp[\"residue_name\"].max() == \"CYS\":  # type: ignore\n            sg_closeness_rating_scaled = 0\n            x_p, y_p, z_p = cys_positions[cys_index]\n            min_distance = 1000  # Initialize with a large number\n\n            points_excluding_index = (\n                cys_positions[:cys_index] + cys_positions[cys_index + 1 :]\n            )\n            for point in points_excluding_index:\n                x_q, y_q, z_q = point\n                distance = np.sqrt(\n                    (x_p - x_q) ** 2 + (y_p - y_q) ** 2 + (z_p - z_q) ** 2\n                )\n                if distance &lt; min_distance:\n                    min_distance = distance\n                sg_closeness_rating_scaled += 10 / ((distance + 1) ** 2)\n\n            cys_index += 1\n\n            res[\"cys_ratio\"].append(float(total_cys_sites) / float(total_residue))\n            res[\"min_dist_to_closest_sulfur\"].append(min_distance)\n            res[\"sulfur_closeness_rating_scaled\"].append(sg_closeness_rating_scaled)\n        else:\n            res[\"cys_ratio\"].append(None)\n            res[\"min_dist_to_closest_sulfur\"].append(None)\n            res[\"sulfur_closeness_rating_scaled\"].append(None)\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.sasa","title":"<code>sasa</code>","text":""},{"location":"api/#procaliper.protein_structure.sasa.SASAData","title":"<code>SASAData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Data class for holding SASA data from computed from a PDB file.</p> <p>Attributes:</p> Name Type Description <code>all_sasa_value</code> <code>list[float]</code> <p>The overall SASA value for each site (computed as sum of atom SASA values).</p> <code>atom_sasa_values</code> <code>list[list[float]]</code> <p>The SASA value for the each atom in each sites. Atoms are ordered from C-terminus to N-terminus according to standard pdb order. For example, in CYS, the last atom is always the SG sulfur.</p> <code>residue_number</code> <code>list[int]</code> <p>The residue number for the site.</p> <code>residue_name</code> <code>list[str]</code> <p>The residue name (three-letter amino acid abbreviation) for the sites.</p> Source code in <code>procaliper/protein_structure/sasa.py</code> <pre><code>class SASAData(TypedDict):\n    \"\"\"Data class for holding SASA data from computed from a PDB file.\n\n    Attributes:\n        all_sasa_value (list[float]): The overall SASA value for each site\n            (computed as sum of atom SASA values).\n        atom_sasa_values (list[list[float]]): The SASA value for the each atom\n            in each sites. Atoms are ordered from C-terminus to N-terminus\n            according to standard pdb order. For example, in CYS, the last atom\n            is always the SG sulfur.\n        residue_number (list[int]): The residue number for the site.\n        residue_name (list[str]): The residue name (three-letter amino acid\n            abbreviation) for the sites.\n    \"\"\"\n\n    all_sasa_value: list[float]\n    atom_sasa_values: list[list[float]]\n    residue_number: list[int]\n    residue_name: list[str]\n</code></pre>"},{"location":"api/#procaliper.protein_structure.sasa.calculate_sasa","title":"<code>calculate_sasa(pdb_filename)</code>","text":"<p>Compute the SASA values for all CYS sites in a PDB file.</p> <p>Uses the ShrakeRupley algorithm implemented in <code>Bio.PDB.SASA.ShrakeRupley</code> with a probe radius of 1.40 and 100 points.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Name Type Description <code>SASAData</code> <code>SASAData</code> <p>A data class for holding SASA data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/sasa.py</code> <pre><code>def calculate_sasa(pdb_filename: str) -&gt; SASAData:\n    \"\"\"Compute the SASA values for all CYS sites in a PDB file.\n\n    Uses the ShrakeRupley algorithm implemented in `Bio.PDB.SASA.ShrakeRupley`\n    with a probe radius of 1.40 and 100 points.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        SASAData: A data class for holding SASA data from computed from a PDB\n            file.\"\"\"\n    p = PDBParser(QUIET=True)\n    struct = p.get_structure(\"\", pdb_filename)  # type: ignore\n\n    sr = ShrakeRupley(probe_radius=PROBE_RADIUS, n_points=N_POINTS, radii_dict=None)\n\n    # Calc sasa values from Residues (from atoms)\n    sr.compute(struct, level=\"R\")  # type: ignore\n\n    # Set up dict\n    res = SASAData(\n        {\n            \"all_sasa_value\": [],\n            \"atom_sasa_values\": [],\n            \"residue_number\": [],\n            \"residue_name\": [],\n        }\n    )\n\n    # Fill dict with CYS sites\n    for x in struct.child_list:  # type: ignore\n        for y in x.child_list:  # type: ignore\n            for z in y.child_list:  # type: ignore\n                res[\"all_sasa_value\"].append(z.sasa)  # type: ignore\n                res[\"atom_sasa_values\"].append([x.sasa for x in z.child_list])  # type: ignore\n                res[\"residue_number\"].append(int(z.id[1]))  # type: ignore\n                res[\"residue_name\"].append(z.resname)  # type: ignore\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.titration","title":"<code>titration</code>","text":""},{"location":"api/#procaliper.protein_structure.titration.TitrationData","title":"<code>TitrationData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Data class for titration data.</p> <p>Attributes:</p> Name Type Description <code>pKa</code> <code>list[float]</code> <p>The pK values for the titration data.</p> <code>protonation_state</code> <code>list[tuple[str, float | str]]</code> <p>The expected protonation states for the titration data.</p> <code>residue_number</code> <code>list[int]</code> <p>The residue numbers for the titration data.</p> <code>residue_name</code> <code>list[str]</code> <p>The residue name (three-letter amino acid abbreviation) for the sites.</p> Source code in <code>procaliper/protein_structure/titration.py</code> <pre><code>class TitrationData(TypedDict):\n    \"\"\"Data class for titration data.\n\n    Attributes:\n        pKa (list[float]): The pK values for the titration data.\n        protonation_state (list[tuple[str, float | str]]): The expected protonation states for the titration data.\n        residue_number (list[int]): The residue numbers for the titration data.\n        residue_name (list[str]): The residue name (three-letter amino acid\n            abbreviation) for the sites.\n    \"\"\"\n\n    pKa: list[float]\n    protonation_state: list[tuple[str, float | str]]\n    residue_number: list[int]\n    residue_name: list[str]\n</code></pre>"},{"location":"api/#procaliper.protein_structure.titration.calculate_titration_propka","title":"<code>calculate_titration_propka(pdb_filename)</code>","text":"<p>Uses propka to calculate titration data for the protein.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Name Type Description <code>TitrationData</code> <code>TitrationData</code> <p>The titration data for the protein.</p> Source code in <code>procaliper/protein_structure/titration.py</code> <pre><code>def calculate_titration_propka(pdb_filename: str) -&gt; TitrationData:\n    \"\"\"Uses propka to calculate titration data for the protein.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        TitrationData: The titration data for the protein.\n    \"\"\"\n    mol = propka.run.single(pdb_filename, optargs=[\"--quiet\"], write_pka=False)\n    gs = mol.conformations[\"AVR\"].groups\n\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)  # type: ignore\n\n    seq = {\n        i: res[\"residue_name\"].iloc[0]\n        for i, res in ppdb.df[\"ATOM\"].groupby(\"residue_number\")\n    }\n    pks = {group.atom.res_num: group.pka_value for group in gs}\n    sv = sorted(seq.items())\n    return TitrationData(\n        # pKa=[group.pka_value for group in gs],\n        pKa=[pks[i] if i in pks else 0 for i, _ in sv],\n        protonation_state=[_state_from_pk(pks[i] if i in pks else 0) for i, _ in sv],\n        residue_name=[v for _, v in sv],\n        residue_number=[i for i, _ in sv],\n    )\n</code></pre>"},{"location":"authors/","title":"authors","text":""},{"location":"authors/#credits","title":"Credits","text":""},{"location":"authors/#development-lead","title":"Development Lead","text":"<ul> <li>AlphaMeter song.feng@pnnl.gov</li> </ul>"},{"location":"authors/#contributors","title":"Contributors","text":"<p>None yet. Why not be the first?</p>"},{"location":"contributing/","title":"contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/PhenoMeters/procaliper/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>procaliper could always use more documentation, whether as part of the official procaliper docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/PhenoMeters/procaliper/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>procaliper</code> for local development.</p> <ol> <li>Fork the <code>procaliper</code> repo on GitHub.</li> <li>Clone your fork locally</li> </ol> <pre><code>    $ git clone git@github.com:your_name_here/procaliper.git\n</code></pre> <ol> <li>Ensure poetry is installed.</li> <li>Install dependencies and start your virtualenv:</li> </ol> <pre><code>    $ poetry install -E test -E doc -E dev\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>    $ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</li> </ol> <pre><code>    $ poetry run tox\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>    $ git add .\n    $ git commit -m \"Your detailed description of your changes.\"\n    $ git push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python &gt;=3.9. Check    https://github.com/PhenoMeters/procaliper/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips```","text":"<pre><code>$ pytest tests.test_procaliper\n</code></pre> <p>```To run a subset of tests.</p>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run:</p> <pre><code>$ poetry patch # possible: major / minor / patch\n$ git push\n$ git push --tags\n</code></pre> <p>Github Actions will then deploy to PyPI if tests pass.</p>"},{"location":"history/","title":"history","text":""},{"location":"history/#history","title":"History","text":""},{"location":"history/#010-2024-01-08","title":"0.1.0 (2024-01-08)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"installation/","title":"installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install procaliper, run this command in your terminal:</p> <pre><code>pip install procaliper\n</code></pre> <p>This is the preferred method to install procaliper, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for procaliper can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>git clone git://github.com/LifeWorks/procaliper\n</code></pre> <p>Or download the tarball:</p> <pre><code>curl -OJL https://github.com/LifeWorks/procaliper/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>pip install .\n</code></pre>"},{"location":"usage/","title":"usage","text":""},{"location":"usage/#usage","title":"Usage","text":"<p>To use procaliper in a project</p> <pre><code>    import procaliper\n</code></pre>"}]}