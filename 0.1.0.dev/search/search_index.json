{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"home","text":""},{"location":"#procaliper","title":"procaliper","text":"<p>Skeleton project created by Python Project Wizard (ppw)</p> <ul> <li>Free software: GPL-3.0-only</li> <li>Documentation: https://LifeWorks.github.io/procaliper/</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"#credits","title":"Credits","text":"<p>This package was created with the ppw tool. For more information, please visit the project page.</p>"},{"location":"api/","title":"modules","text":"<p>Top-level package for procaliper.</p>"},{"location":"api/#procaliper.Protein","title":"<code>Protein</code>","text":"Source code in <code>procaliper/protein.py</code> <pre><code>class Protein:\n    UNIPROT_SITE_PATTERNS = {\n        \"Active site\": [(r\"ACT_SITE (\\d+);\", False)],\n        \"Binding site\": [\n            (r\"BINDING (\\d+);\", False),\n            (r\"BINDING (\\d+)\\.\\.(\\d+);\", False),\n        ],\n        \"DNA binding\": [\n            (r\"DNA_BIND (\\d+);\", False),\n            (r\"DNA_BIND (\\d+)\\.\\.(\\d+);\", False),\n        ],\n        \"Disulfide bond\": [\n            (r\"DISULFID (\\d+);\", False),\n            (r\"DISULFID (\\d+)\\.\\.(\\d+);\", False),\n        ],\n        \"Beta strand\": [(r\"STRAND (\\d+);\", True), (r\"STRAND (\\d+)\\.\\.(\\d+);\", True)],\n        \"Helix\": [(r\"HELIX (\\d+);\", True), (r\"HELIX (\\d+)\\.\\.(\\d+);\", True)],\n        \"Turn\": [(r\"TURN (\\d+);\", True), (r\"TURN (\\d+)\\.\\.(\\d+);\", True)],\n    }\n\n    UNIPROT_SITE_PATTERNS_RECTIFIED = {\n        \"active_site\": [(r\"ACT_SITE (\\d+);\", False)],\n        \"binding_site\": [\n            (r\"BINDING (\\d+);\", False),\n            (r\"BINDING (\\d+)\\.\\.(\\d+);\", False),\n        ],\n        \"dna_binding\": [\n            (r\"DNA_BIND (\\d+);\", False),\n            (r\"DNA_BIND (\\d+)\\.\\.(\\d+);\", False),\n        ],\n        \"disulfide_bond\": [\n            (r\"DISULFID (\\d+);\", False),\n            (r\"DISULFID (\\d+)\\.\\.(\\d+);\", False),\n        ],\n        \"beta_strand\": [(r\"STRAND (\\d+);\", True), (r\"STRAND (\\d+)\\.\\.(\\d+);\", True)],\n        \"helix\": [(r\"HELIX (\\d+);\", True), (r\"HELIX (\\d+)\\.\\.(\\d+);\", True)],\n        \"turn\": [(r\"TURN (\\d+);\", True), (r\"TURN (\\d+)\\.\\.(\\d+);\", True)],\n    }\n\n    UNIPROT_API_DEFAULT_FIELDS = [\n        \"id\",\n        \"reviewed\",\n        \"protein_name\",\n        \"gene_names\",\n        \"organism_name\",\n        \"length\",\n        \"sequence\",\n        \"ft_act_site\",\n        \"ft_binding\",\n        \"ft_dna_bind\",\n        \"ft_disulfid\",\n        \"ft_strand\",\n        \"ft_helix\",\n        \"ft_turn\",\n    ]\n\n    def __init__(self) -&gt; None:\n        self.data: dict[str, Any] = {}\n        self.pdb_location_relative: str | None = None\n        self.pdb_location_absolute: str | None = None\n\n        self.sasa_data: structure.sasa.SASAData | None = None\n        self.charge_data: structure.charge.ChargeData | None = None\n        self.size_data: structure.size.SizeData | None = None\n        self.titration_data: structure.titration.TitrationData | None = None\n        pass\n\n    def _rectify_data_labels(self) -&gt; None:\n        \"\"\"\n        Standardize the features names in self.data\n\n        Replaces all spaces with underscores and lowercases the keys\n        \"\"\"\n        for k in list(self.data.keys()):\n            new_key = k.replace(\" \", \"_\").lower()\n            self.data[new_key] = self.data.pop(k)\n\n    @classmethod\n    def from_uniprot_row(cls, row: dict[str, Any]) -&gt; Protein:\n        p = cls()\n        if \"Sequence\" in row:\n            p.data[\"sequence\"] = row[\"Sequence\"]\n        elif \"sequence\" in row:\n            p.data[\"sequence\"] = row[\"sequence\"]\n        else:\n            raise ValueError(f\"Sequence not found in row: {row}\")\n\n        for key, value in row.items():\n            if key in cls.UNIPROT_SITE_PATTERNS:\n                p.data[f\"{key}_sites\"] = p._extract_sites(\n                    value,\n                    cls.UNIPROT_SITE_PATTERNS[key],\n                )\n                p.data[f\"{key}_cysteine_sites\"] = [\n                    site\n                    for site in p.data[f\"{key}_sites\"]\n                    if p._is_site_aa(site, aa=\"C\")\n                ]\n            else:\n                p.data[key] = value\n\n        p._rectify_data_labels()\n        return p\n\n    @classmethod\n    def from_uniprot_id(\n        cls,\n        uniprot_id: str,\n        fields: list[str] | None = None,\n        from_db: str = \"UniProtKB_AC-ID\",\n        to_db: str = \"UniProtKB-Swiss-Prot\",\n    ) -&gt; Protein:\n        if not fields:\n            fields = cls.UNIPROT_API_DEFAULT_FIELDS\n\n        mapper = ProtMapper()\n\n        result, error = mapper.get(  # type: ignore\n            ids=[uniprot_id], fields=fields, from_db=from_db, to_db=to_db\n        )\n        if error:\n            raise ValueError(f\"Uniprot id {error} not retrieved\")\n        result.rename(columns={\"From\": \"entry\"}, inplace=True)\n        if \"Length\" in result.columns:\n            result[\"Length\"] = pd.to_numeric(result[\"Length\"])  # type: ignore\n        return cls.from_uniprot_row(result.iloc[0].to_dict())  # type: ignore\n\n    @classmethod\n    def list_from_uniprot_ids(\n        cls,\n        uniprot_ids: list[str],\n        fields: list[str] | None = None,\n        from_db: str = \"UniProtKB_AC-ID\",\n        to_db: str = \"UniProtKB-Swiss-Prot\",\n    ) -&gt; list[Protein]:\n        if not fields:\n            fields = cls.UNIPROT_API_DEFAULT_FIELDS\n\n        mapper = ProtMapper()\n\n        result, error = mapper.get(  # type: ignore\n            ids=uniprot_ids, fields=fields, from_db=from_db, to_db=to_db\n        )\n        if error:\n            raise ValueError(f\"Uniprot id {error} not retrieved\")\n        result.rename(columns={\"From\": \"entry\"}, inplace=True)\n\n        if \"Length\" in result.columns:\n            result[\"Length\"] = pd.to_numeric(result[\"Length\"])  # type: ignore\n        return [cls.from_uniprot_row(row.to_dict()) for _, row in result.iterrows()]  # type: ignore\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Protein):\n            return False\n        return (\n            self.data == other.data\n            and self.sasa_data == other.sasa_data\n            and self.charge_data == other.charge_data\n            and self.size_data == other.size_data\n        )\n\n    def get_sasa(self) -&gt; structure.sasa.SASAData:\n        if self.sasa_data:\n            return self.sasa_data\n\n        if self.pdb_location_absolute:\n            self.sasa_data = structure.sasa.calculate_sasa(\n                self.pdb_location_absolute,\n                self.data[\"entry\"],\n            )\n            return self.sasa_data\n        else:\n            raise ValueError(\n                \"SASA data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_charge(self) -&gt; structure.charge.ChargeData:\n        if self.charge_data:\n            return self.charge_data\n\n        if self.pdb_location_absolute:\n            self.charge_data = structure.charge.calculate_charge(\n                self.pdb_location_absolute,\n                self.data[\"entry\"],\n            )\n            return self.charge_data\n        else:\n            raise ValueError(\n                \"Charge data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_size(self) -&gt; structure.size.SizeData:\n        if self.size_data:\n            return self.size_data\n\n        if self.pdb_location_absolute:\n            self.size_data = structure.size.calculate_size(\n                self.pdb_location_absolute,\n                self.data[\"entry\"],\n            )\n            return self.size_data\n        else:\n            raise ValueError(\n                \"Size data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_titration(self) -&gt; structure.titration.TitrationData:\n        return self.get_titration_from_propka()\n\n    def get_titration_from_propka(self) -&gt; structure.titration.TitrationData:\n        if self.titration_data:\n            return self.titration_data\n\n        if self.pdb_location_absolute:\n            self.titration_data = structure.titration.calculate_titration_propka(\n                self.pdb_location_absolute,\n            )\n            return self.titration_data\n        else:\n            raise ValueError(\n                \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_titration_from_pypka(self) -&gt; structure.titration.TitrationData:\n        if self.titration_data:\n            return self.titration_data\n\n        if self.pdb_location_absolute:\n            self.titration_data = structure.titration.calculate_titration_pypka(\n                self.pdb_location_absolute,\n            )\n            return self.titration_data\n        else:\n            raise ValueError(\n                \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_titration_from_pkai(self) -&gt; structure.titration.TitrationData:\n        if self.titration_data:\n            return self.titration_data\n\n        if self.pdb_location_absolute:\n            self.titration_data = structure.titration.calculate_titration_pkai(\n                self.pdb_location_absolute,\n            )\n            return self.titration_data\n        else:\n            raise ValueError(\n                \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def unravel_sites(\n        self,\n        selected_aas: None | set[AminoAcidLetter] = None,\n        selected_keys: None | set[str] = None,\n    ) -&gt; dict[str, list[Any]]:\n        if not selected_keys:\n            selected_keys = set(self.data.keys()) - {\"sequence\"}\n\n        site_keys = set(Protein.UNIPROT_SITE_PATTERNS_RECTIFIED.keys()) &amp; selected_keys\n        other_keys = selected_keys - site_keys\n\n        res: dict[str, list[Any]] = {k: [] for k in other_keys | site_keys}\n        res[\"letter\"] = []\n        res[\"position\"] = []\n\n        for index, site in enumerate(self.data[\"sequence\"]):\n            site_dict: dict[str, Any] = {k: self.data[k] for k in other_keys}\n            site_dict[\"letter\"] = site\n            site_dict[\"position\"] = index + 1\n            if selected_aas and site not in selected_aas:\n                continue\n\n            for key in site_keys:\n                site_dict[key] = index in self.data[f\"{key}_sites\"]\n\n            for k, v in site_dict.items():\n                res[k].append(v)\n\n        return res\n\n    def fetch_pdb(self, save_path: str | None = None, url: str | None = None) -&gt; None:\n        if not url:\n            url = f\"https://alphafold.ebi.ac.uk/files/AF-{self.data['entry']}-F1-model_v4.pdb\"\n        if not save_path:\n            save_path = f\"{self.data['entry']}.pdb\"\n\n        response = requests.get(url)\n\n        if response.status_code != 200:\n            raise Exception(f\"Failed to fetch PDB: {response.status_code}\")\n\n        with open(save_path, \"wb+\") as f:\n            f.write(response.content)\n\n        self.pdb_location_relative = save_path\n        self.pdb_location_absolute = os.path.abspath(save_path)\n\n    def _extract_sites(\n        self, site_description: str, patterns: list[tuple[str, bool]]\n    ) -&gt; list[int]:\n        sites: list[int] = []\n        if (\n            str(site_description) == \"nan\"\n        ):  # this will be the missing value default in pandas--is there a more elegant way to handle this?\n            return sites\n        for pattern, expand_range in patterns:\n            matches = cast(list[str], re.findall(pattern, site_description))\n\n            for match in matches:\n                if isinstance(match, tuple):\n                    start, end = int(match[0]), int(match[1])\n                    if expand_range:\n                        sites.extend(\n                            range(start, end + 1)\n                        )  # Include all values in the range from start to end\n                    else:\n                        sites.extend([start, end])  # Add start and end points\n                else:\n                    sites.append(int(match))\n        return sites\n\n    def _is_site_aa(self, site: int, aa: AminoAcidLetter = \"C\") -&gt; bool:\n        \"\"\"_summary_\n\n        Parameters\n        ----------\n        site : int\n            Position of amino acid (1-indexed)\n        aa : str, optional\n            Amino acid code to test against by default \"C\" (cysteine)\n\n        Returns\n        -------\n        bool\n            True if the amino acid is a the position `site` is as specified.\n\n        Raises\n        ------\n        ValueError\n            If the protein does not have a defined sequence.\n        \"\"\"\n        if \"sequence\" not in self.data:\n            raise ValueError(\"Sequence entry not found in data\")\n\n        sequence = self.data[\"sequence\"]\n\n        return site &lt;= len(sequence) and sequence[site - 1] == aa\n</code></pre>"},{"location":"authors/","title":"authors","text":""},{"location":"authors/#credits","title":"Credits","text":""},{"location":"authors/#development-lead","title":"Development Lead","text":"<ul> <li>AlphaMeter song.feng@pnnl.gov</li> </ul>"},{"location":"authors/#contributors","title":"Contributors","text":"<p>None yet. Why not be the first?</p>"},{"location":"contributing/","title":"contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/LifeWorks/procaliper/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>procaliper could always use more documentation, whether as part of the official procaliper docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/LifeWorks/procaliper/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>procaliper</code> for local development.</p> <ol> <li>Fork the <code>procaliper</code> repo on GitHub.</li> <li>Clone your fork locally</li> </ol> <pre><code>    $ git clone git@github.com:your_name_here/procaliper.git\n</code></pre> <ol> <li>Ensure poetry is installed.</li> <li>Install dependencies and start your virtualenv:</li> </ol> <pre><code>    $ poetry install -E test -E doc -E dev\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>    $ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</li> </ol> <pre><code>    $ tox\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>    $ git add .\n    $ git commit -m \"Your detailed description of your changes.\"\n    $ git push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check    https://github.com/LifeWorks/procaliper/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips```","text":"<pre><code>$ pytest tests.test_procaliper\n</code></pre> <p>```To run a subset of tests.</p>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run:</p> <pre><code>$ poetry patch # possible: major / minor / patch\n$ git push\n$ git push --tags\n</code></pre> <p>Github Actions will then deploy to PyPI if tests pass.</p>"},{"location":"history/","title":"history","text":""},{"location":"history/#history","title":"History","text":""},{"location":"history/#010-2024-01-08","title":"0.1.0 (2024-01-08)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"installation/","title":"installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install procaliper, run this command in your terminal:</p> <pre><code>pip install procaliper\n</code></pre> <p>This is the preferred method to install procaliper, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for procaliper can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>git clone git://github.com/LifeWorks/procaliper\n</code></pre> <p>Or download the tarball:</p> <pre><code>curl -OJL https://github.com/LifeWorks/procaliper/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>pip install .\n</code></pre>"},{"location":"usage/","title":"usage","text":""},{"location":"usage/#usage","title":"Usage","text":"<p>To use procaliper in a project</p> <pre><code>    import procaliper\n</code></pre>"}]}