{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"home","text":""},{"location":"#procaliper","title":"procaliper","text":"<p>A tool for fetching and organizing protein data in order to perform structure calculations.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install from PyPI:</p> <pre><code>pip install procaliper\n</code></pre>"},{"location":"#extras","title":"extras","text":"<p>During installation, <code>procaliper</code> will also install <code>openbabel-wheel</code>. If you require specialized features of <code>openbabel</code> that are not available in this precompiled version, please run <code>pip uninstall openbabel-wheel</code> after <code>procaliper</code> is installed and provide your own version of the <code>openbabel</code> python library.</p> <p>Optional feature dependencies can be installed as follows:</p> <pre><code>pip install procaliper[nglview,pka]\n</code></pre> <p>The <code>nglview</code> extra provides the ability to visualize protein structures in a graphical notebook environment.</p> <p>The <code>pka</code> extra provides additional methods for computing disassociation constants (typically denoted \\(pK_a\\)). Note that installing this extra requires obtaining  a <code>DelPhi</code> license. Furthermore, these additional methods require an older version of <code>numpy</code> (version <code>1.26.4</code>) and <code>python</code> version between <code>3.9</code> and <code>3.11</code> to properly function. If the <code>pka</code> extra is not installed, <code>procaliper</code> will use propka for \\(pK_a\\) calculation.</p>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>A basic example is provided here. See the examples folder for further examples.</p> <pre><code>import procaliper as pc\n\n# Read in or download protein structure\nprotein = pc.Protein.from_uniprot_id(\"A0A0B4J2F0\") # create a protein object from UniProt metadata using a UniProt ID\n# alternatively, you can read in a protein from a UniProt Table using `Protein.from_uniprot_row`\n\n# Download &amp; save protein structure from AlphaFold\nprotein.fetch_pdb(save_path=\"A0A0B4J2F0.pdb\") \n# Alternatively, `protein.register_local_pdb(file)` can be used to specify a previously downloaded pdb file\n\n# Compute structure features\nsasa = protein.get_sasa() # compute site-level SASA values\ncharge = protein.get_charge() # compute site-level charges\ntitr = protein.get_titration() # compute site-level titration (pKa) data\n# The results from the above calculations are autmatically stored in the `protein` object.\n\n# Get a table of site-level data\nsite_data = protein.unravel_sites() # returns a dictionary of lists; readable, e.g., by `pandas`\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome!</p> <p>See Contributing for detailed instructions.</p>"},{"location":"#license","title":"License","text":"<p>This code is released under GPL v3. See our License for detailed information.</p> <p>By default, <code>procaliper</code> does not have any dependencies that are not freely licensed. However, additional features can be installed that rely on restricted software. That is, please note that some optional dependencies are not FOSS. Specifically, the <code>pka</code> extra requires a <code>DelPhi</code> license. We encourage caution when using software that is not free and open source, especially for contributions to the scientific literature.</p>"},{"location":"#credits","title":"Credits","text":"<p>This work is supported by the Predictive Phenomics Initiative at Pacific Northwest National Laboratory.</p>"},{"location":"api/","title":"modules","text":"<p>Top-level package for procaliper.</p>"},{"location":"api/#procaliper.Protein","title":"<code>Protein</code>","text":"Source code in <code>procaliper/_protein.py</code> <pre><code>class Protein:\n    UNIPROT_SITE_PATTERNS = {\n        \"Active site\": \"ACT_SITE\",\n        \"Binding site\": \"BINDING\",\n        \"DNA binding\": \"DNA_BIND\",\n        \"Disulfide bond\": \"DISULFID\",\n        \"Beta strand\": \"STRAND\",\n        \"Helix\": \"HELIX\",\n        \"Turn\": \"TURN\",\n    }\n\n    UNIPROT_SITE_PATTERNS_RECTIFIED = {\n        \"active\": \"ACT_SITE\",\n        \"binding\": \"BINDING\",\n        \"dna_binding\": \"DNA_BIND\",\n        \"disulfide_bond\": \"DISULFID\",\n        \"beta_strand\": \"STRAND\",\n        \"helix\": \"HELIX\",\n        \"turn\": \"TURN\",\n    }\n\n    UNIPROT_API_DEFAULT_FIELDS = [\n        \"id\",\n        \"reviewed\",\n        \"protein_name\",\n        \"gene_names\",\n        \"organism_name\",\n        \"length\",\n        \"sequence\",\n        \"ft_act_site\",\n        \"ft_binding\",\n        \"ft_dna_bind\",\n        \"ft_disulfid\",\n        \"ft_strand\",\n        \"ft_helix\",\n        \"ft_turn\",\n    ]\n\n    def __init__(self) -&gt; None:\n        self.data: dict[str, Any] = {}\n        self.pdb_location_relative: str | None = None\n        self.pdb_location_absolute: str | None = None\n\n        self.site_annotations: SiteAnnotations = SiteAnnotations(\"\")\n        self.custom_site_data: CustomSiteData = CustomSiteData([], {})\n\n        self.confidence_data: list[float] | None = None\n        self.sasa_data: structure.sasa.SASAData | None = None\n        self.charge_data: structure.charge.ChargeData | None = None\n        self.cysteine_data: structure.cysteine_data.CysteineData | None = None\n        self.titration_data: structure.titration.TitrationData | None = None\n        pass\n\n    def _rectify_label(self, label: str) -&gt; str:\n        new_label = label.replace(\" \", \"_\").lower()\n        new_label = new_label.removesuffix(\"_site_sites\")\n        new_label = new_label.removesuffix(\"_site\")\n        return new_label\n\n    def _rectify_data_labels(self) -&gt; None:\n        \"\"\"\n        Standardize the features names in self.data\n\n        Replaces all spaces with underscores and lowercases the keys, and then\n        replaces all instances of \"_site_sites\" with \"_sites\"\n        \"\"\"\n        for k in list(self.data.keys()):\n            new_key = self._rectify_label(k)\n            self.data[new_key] = self.data.pop(k)\n\n    @classmethod\n    def from_uniprot_row(cls, row: dict[str, Any]) -&gt; Protein:\n        \"\"\"Create a new Protein object from a row from a Uniprot table\n\n        Args:\n            row (dict[str, Any]): Contains the data from the Uniprot table. Must\n                have \"Sequence\" or \"sequence\" as a key.\n\n        Raises:\n            ValueError: If \"Sequence\" or \"sequence\" is not found in the row.\n\n        Returns:\n            Protein: A processed and standardized protein object.\n        \"\"\"\n        p = cls()\n        if \"Sequence\" in row:\n            p.data[\"sequence\"] = row[\"Sequence\"]\n        elif \"sequence\" in row:\n            p.data[\"sequence\"] = row[\"sequence\"]\n        else:\n            raise ValueError(f\"Sequence not found in row: {row}\")\n        p.custom_site_data.add_residue_numbers(len(p.data[\"sequence\"]))\n        p.site_annotations = SiteAnnotations(p.data[\"sequence\"])\n        for key, value in row.items():\n            key = p._rectify_label(key)\n            if key in cls.UNIPROT_SITE_PATTERNS_RECTIFIED:\n                uniprot_description_id = cls.UNIPROT_SITE_PATTERNS_RECTIFIED[key]\n                p.site_annotations.extract_annotation(uniprot_description_id, value)\n            elif key in cls.UNIPROT_SITE_PATTERNS:\n                uniprot_description_id = cls.UNIPROT_SITE_PATTERNS[key]\n                p.site_annotations.extract_annotation(uniprot_description_id, value)\n            else:\n                if value != value:\n                    value = \"\"\n                p.data[key] = value\n        return p\n\n    @classmethod\n    def from_uniprot_id(\n        cls,\n        uniprot_id: str,\n        fields: list[str] | None = None,\n        from_db: str = \"UniProtKB_AC-ID\",\n        to_db: str = \"UniProtKB-Swiss-Prot\",\n    ) -&gt; Protein:\n        \"\"\"Create a new Protein object from a Uniprot ID (fetches with Uniprot API)\n\n        Args:\n            uniprot_id (str): The Uniprot ID of the protein.\n            fields (list[str] | None, optional): The fields to retrieve from\n                Uniprot. If `None`, `Protein.UNIPROT_API_DEFAULT_FIELDS` is used.\n            from_db (str, optional): The database to retrieve the ID from.\n                Defaults to \"UniProtKB_AC-ID\".\n            to_db (str, optional): The database to map to.\n                Defaults to \"UniProtKB-Swiss-Prot\".\n\n        Raises:\n            ValueError: If we cannot retrieve the Uniprot ID.\n\n        Returns:\n            Protein: A processed and standardized protein object.\n        \"\"\"\n\n        if not fields:\n            fields = cls.UNIPROT_API_DEFAULT_FIELDS\n\n        mapper = ProtMapper()\n\n        result, error = mapper.get(\n            ids=[uniprot_id], fields=fields, from_db=from_db, to_db=to_db\n        )\n        if error:\n            raise ValueError(f\"Uniprot id not retrieved: {error}\")\n        result.rename(columns={\"From\": \"entry\"}, inplace=True)\n        if \"Length\" in result.columns:\n            result[\"Length\"] = pd.to_numeric(result[\"Length\"])\n        return cls.from_uniprot_row(result.iloc[0].to_dict())\n\n    @classmethod\n    def list_from_uniprot_ids(\n        cls,\n        uniprot_ids: list[str],\n        fields: list[str] | None = None,\n        from_db: str = \"UniProtKB_AC-ID\",\n        to_db: str = \"UniProtKB-Swiss-Prot\",\n    ) -&gt; list[Protein]:\n        \"\"\"Create a list of Protein objects from a list of Uniprot IDs (fetches with Uniprot API)\n\n        Args:\n            uniprot_ids (list[str]): The Uniprot IDs of the proteins.\n            fields (list[str] | None, optional): The fields to retrieve from\n                Uniprot. If `None`, `Protein.UNIPROT_API_DEFAULT_FIELDS` is used.\n            from_db (str, optional): The database to retrieve the IDs from.\n                Defaults to \"UniProtKB_AC-ID\".\n            to_db (str, optional): The database to map to.\n                Defaults to \"UniProtKB-Swiss-Prot\".\n\n        Raises:\n            ValueError: If we cannot retrieve the Uniprot IDs.\n\n        Returns:\n            list[Protein]: A list of processed and standardized protein objects.\n        \"\"\"\n        if not fields:\n            fields = cls.UNIPROT_API_DEFAULT_FIELDS\n\n        mapper = ProtMapper()\n\n        result, error = mapper.get(\n            ids=uniprot_ids, fields=fields, from_db=from_db, to_db=to_db\n        )\n        if error:\n            raise ValueError(f\"Uniprot id not retrieved: {error}\")\n        result.rename(columns={\"From\": \"entry\"}, inplace=True)\n\n        if \"Length\" in result.columns:\n            result[\"Length\"] = pd.to_numeric(result[\"Length\"])\n        return [cls.from_uniprot_row(row.to_dict()) for _, row in result.iterrows()]\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Protein):\n            return False\n        return (\n            self.data == other.data\n            and self.sasa_data == other.sasa_data\n            and self.charge_data == other.charge_data\n            and self.cysteine_data == other.cysteine_data\n        )\n\n    def residue_data_frame(self) -&gt; pd.DataFrame:\n        d = dict(\n            chain(\n                self.get_charge().items(),\n                self.get_sasa().items(),\n                self.get_cysteine_data().items(),\n                self.get_titration().items(),\n            )\n        )\n        d[\"pLDDT\"] = self.get_confidence()\n\n        return pd.DataFrame(d)\n\n    def get_biopandas_pdb_dataframe(self) -&gt; PandasPdb:\n        \"\"\"Get the PDB dataframe for the protein.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `pdb_location_absolute` is not set.\n\n        Returns:\n            PandasPdb: A biopandas dataframe that contains the PDB file information.\n        \"\"\"\n        if not self.pdb_location_absolute:\n            raise ValueError(\"PDB location not set; use `fetch_pdb` first\")\n        ppdb = PandasPdb()\n        return ppdb.read_pdb(self.pdb_location_absolute)\n\n    def get_biopython_structure(self) -&gt; Structure:\n        \"\"\"Get the biopython structure for the protein.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `pdb_location_absolute` is not set.\n            ValueError: If the PDB file cannot be parsed.\n\n        Returns:\n            Structure: A biopython Structure object for the protein.\n        \"\"\"\n        if not self.pdb_location_absolute:\n            raise ValueError(\"PDB location not set; use `fetch_pdb` first\")\n        p = PDBParser(QUIET=True)\n        structure = p.get_structure(\"\", self.pdb_location_absolute)\n        if not isinstance(structure, Structure):\n            raise ValueError(\"Unable to parse PDB file.\")\n        return structure\n\n    def get_biopython_residues(self) -&gt; list[Residue]:\n        \"\"\"Get the biopython residues for the protein.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `pdb_location_absolute` is not set.\n\n        Returns:\n            list[Residue]: A list of biopython residues for the protein.\n        \"\"\"\n        if not self.pdb_location_absolute:\n            raise ValueError(\"PDB location not set; use `fetch_pdb` first\")\n        p = PDBParser(QUIET=True)\n        structure = p.get_structure(\"\", self.pdb_location_absolute)\n        reslist = [res for model in structure for chain in model for res in chain]\n        return reslist\n\n    def get_confidence(self) -&gt; list[float]:\n        \"\"\"Fetches precomputed confidence data from pdb file.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `confidence_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            list[float]: A list of confidence values for each residue.\n        \"\"\"\n        if self.confidence_data:\n            return self.confidence_data\n\n        if self.pdb_location_absolute:\n            self.confidence_data = structure.confidence.residue_pLDDT(\n                self.pdb_location_absolute,\n            )\n            return self.confidence_data\n        else:\n            raise ValueError(\n                \"Confidence data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_sasa(self) -&gt; structure.sasa.SASAData:\n        \"\"\"Fetches precomputed SASA data for the protein, or computes it.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `sasa_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            structure.sasa.SASAData: A :class:`protein_structure.sasa.SASAData`\n                object containing the SASA values for residues and atoms.\n        \"\"\"\n        if self.sasa_data:\n            return self.sasa_data\n\n        if self.pdb_location_absolute:\n            self.sasa_data = structure.sasa.calculate_sasa(\n                self.pdb_location_absolute,\n            )\n            return self.sasa_data\n        else:\n            raise ValueError(\n                \"SASA data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_charge(self, method: str = \"gasteiger\") -&gt; structure.charge.ChargeData:\n        \"\"\"Fetches precomputed charge data for the protein, or computes it.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Args:\n            method (str, optional): The method used for the charge calculation.\n                Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to\n                'gasteiger'. For a full list reference\n                https://open-babel.readthedocs.io/en/latest/Charges/charges.html\n\n        Raises:\n            ValueError: If `charge_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            structure.charge.ChargeData: A :class:`protein_structure.charge.ChargeData`\n                object containing the charge values for residues and atoms.\n        \"\"\"\n        if self.charge_data:\n            if self.charge_data[\"charge_method\"]:\n                if self.charge_data[\"charge_method\"][0] == method:\n                    return self.charge_data\n\n        if self.pdb_location_absolute:\n            self.charge_data = structure.charge.calculate_charge(\n                self.pdb_location_absolute,\n                method=method,\n            )\n\n            self.last_charge_method = method\n\n            return self.charge_data\n        else:\n            raise ValueError(\n                \"Charge data for specified method not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_cysteine_data(self) -&gt; structure.cysteine_data.CysteineData:\n        \"\"\"Fetches precomputed size data for the protein, or computes it.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `cysteine_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            structure.size.CysteineData: A :class:`protein_structure.size.CysteineData`\n                object containing the size values for cystein sites.\n        \"\"\"\n        if self.cysteine_data:\n            return self.cysteine_data\n\n        if self.pdb_location_absolute:\n            self.cysteine_data = structure.cysteine_data.calculate_cysteine_data(\n                self.pdb_location_absolute,\n            )\n            return self.cysteine_data\n        else:\n            raise ValueError(\n                \"Size data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_titration(self) -&gt; structure.titration.TitrationData:\n        \"\"\"Runs the default titration calculation for the protein.\n\n        Equivalent to running `self.get_titration_from_propka`.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `titration_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            structure.titration.TitrationData: A\n                :class:`protein_structure.titration.TitrationData` object containing\n                the titration values for residues.\n        \"\"\"\n        return self.get_titration_from_propka()\n\n    def get_titration_from_propka(self) -&gt; structure.titration.TitrationData:\n        \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n        Uses :func:`protein_structure.titration.calculate_titration_propka` if\n        `self.titration_data` is not already stored.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `titration_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns:\n            structure.titration.TitrationData: A\n                :class:`protein_structure.titration.TitrationData` object containing\n                the titration values for residues.\"\"\"\n        if self.titration_data:\n            return self.titration_data\n\n        if self.pdb_location_absolute:\n            self.titration_data = structure.titration.calculate_titration_propka(\n                self.pdb_location_absolute,\n            )\n            return self.titration_data\n        else:\n            raise ValueError(\n                \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_titration_from_pypka(self) -&gt; structure.titration.TitrationData:\n        \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n        Uses :func:`protein_structure.titration.calculate_titration_pypka` if\n        `self.titration_data` is not already stored. Requires pypka to be\n        installed, which has dependencies that are not FOSS. Please be sure to\n        verify that you are legally allowed to use pypka.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `titration_data` is not already stored and\n                `pdb_location_absolute` is not set. ImportError: If pypka is not\n                installed.\n\n        Returns:\n            structure.titration.TitrationData: A\n                :class:`protein_structure.titration.TitrationData` object containing\n                the titration values forresidues.\"\"\"\n\n        if self.titration_data:\n            return self.titration_data\n\n        if self.pdb_location_absolute:\n            self.titration_data = structure.titration.calculate_titration_pypka(\n                self.pdb_location_absolute,\n            )\n            return self.titration_data\n        else:\n            raise ValueError(\n                \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def get_titration_from_pkai(self) -&gt; structure.titration.TitrationData:\n        \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n        Uses :func:`protein_structure.titration.calculate_titration_pkai` if\n        `self.titration_data` is not already stored. Requires pkai to be\n        installed. Note that this method is a deep-learning model, not a\n        physics-based calculation.\n\n        Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n        file in `self.pdb_location_absolute`.\n\n        Raises:\n            ValueError: If `titration_data` is not already stored and\n                `pdb_location_absolute` is not set.\n\n        Returns: structure.titration.TitrationData: A\n            :class:`protein_structure.titration.TitrationData` object containing\n                the titration values for residues.\"\"\"\n        if self.titration_data:\n            return self.titration_data\n\n        if self.pdb_location_absolute:\n            self.titration_data = structure.titration.calculate_titration_pkai(\n                self.pdb_location_absolute,\n            )\n            return self.titration_data\n        else:\n            raise ValueError(\n                \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n            )\n\n    def add_custom_site_data_column(\n        self, key: str, site_data: list[Any], overwrite: bool = False\n    ) -&gt; None:\n        if not self.custom_site_data.residue_number:\n            self.custom_site_data.add_residue_numbers(len(self.data[\"sequence\"]))\n        self.custom_site_data.add_site_data(key, site_data, overwrite=overwrite)\n\n    def unravel_sites(\n        self,\n        selected_aas: None | set[AminoAcidLetter] = None,\n        selected_keys: None | set[str] = None,\n    ) -&gt; dict[str, list[Any]]:\n        \"\"\"Split the protein into individual sites, recording values for each.\n\n        Args:\n            selected_aas: A set of amino acids letters to include in the output.\n                If `None` (default), all amino acids will be included.\n            selected_keys: A set of keys belonging to this `Protein` object's\n                `data` dictionary to include in the output. If `None` (default),\n                all keys are used.\n\n        Returns:\n            dict[str, list[Any]]: A dictionary mapping keys to lists of values.\n                Each list is a parallel array of the same length as the protein\n                sequence (after filtering out non-selected amino acids).\"\"\"\n        tbl = self.site_annotations.table() | self.custom_site_data.table()\n        if selected_keys is None:\n            selected_keys = (set(tbl.keys()) | set(self.data.keys())) - {\"sequence\"}\n        tbl_keys = selected_keys &amp; set(tbl.keys())\n        data_keys = selected_keys &amp; set(self.data.keys())\n        assert tbl_keys.isdisjoint(data_keys)\n        res: dict[str, list[Any]] = {k: [] for k in selected_keys}\n        for index, site in enumerate(self.data[\"sequence\"]):\n            if selected_aas and site not in selected_aas:\n                continue\n            for k in tbl_keys:\n                res[k].append(tbl[k][index])\n            for k in data_keys:\n                res[k].append(self.data[k])  # will be the same for all sites\n\n        return res\n\n    def fetch_pdb(self, save_path: str | None = None, url: str | None = None) -&gt; None:\n        \"\"\"Fetches the PDB file for the protein (from the AlphaFold database by default).\n\n        Args:\n            save_path (str | None, optional): The path to save the PDB file to.\n                Defaults to `None`.\n            url (str | None, optional): The URL to fetch the PDB file from.\n                Defaults to `None`, in which case the AlphaFold database is used.\n\n        Raises:\n            Exception: If the response status code is not 200, meaning we could\n                not fetch the PDB from the database.\"\"\"\n        if not url:\n            url = f\"https://alphafold.ebi.ac.uk/files/AF-{self.data['entry']}-F1-model_v4.pdb\"\n        if not save_path:\n            save_path = f\"{self.data['entry']}.pdb\"\n\n        response = requests.get(url)\n\n        if response.status_code != 200:\n            raise Exception(f\"Failed to fetch PDB: {response.status_code}\")\n\n        with open(save_path, \"wb+\") as f:\n            f.write(response.content)\n\n        self.pdb_location_relative = save_path\n        self.pdb_location_absolute = os.path.abspath(save_path)\n\n    def register_local_pdb(self, path_to_pdb_file: str | None = None) -&gt; None:\n        \"\"\"Sets pdb file for protein object using local pdb file.\n\n        Args:\n            path_to_pdb_file (str | None, optional): Path to local PDB file.\n                Defaults to `None`, in which case it assumes a file with 'entry'.pdb.\"\"\"\n        if not path_to_pdb_file:\n            path_to_pdb_file = f\"{self.data['entry']}.pdb\"\n        self.pdb_location_relative = path_to_pdb_file\n        self.pdb_location_absolute = os.path.abspath(path_to_pdb_file)\n\n    def _is_site_aa(self, site: int, aa: AminoAcidLetter = \"C\") -&gt; bool:\n        if \"sequence\" not in self.data:\n            raise ValueError(\"Sequence entry not found in data\")\n\n        sequence = self.data[\"sequence\"]\n\n        return site &lt;= len(sequence) and sequence[site - 1] == aa\n</code></pre>"},{"location":"api/#procaliper.Protein.fetch_pdb","title":"<code>fetch_pdb(save_path=None, url=None)</code>","text":"<p>Fetches the PDB file for the protein (from the AlphaFold database by default).</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <code>str | None</code> <p>The path to save the PDB file to. Defaults to <code>None</code>.</p> <code>None</code> <code>url</code> <code>str | None</code> <p>The URL to fetch the PDB file from. Defaults to <code>None</code>, in which case the AlphaFold database is used.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the response status code is not 200, meaning we could not fetch the PDB from the database.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def fetch_pdb(self, save_path: str | None = None, url: str | None = None) -&gt; None:\n    \"\"\"Fetches the PDB file for the protein (from the AlphaFold database by default).\n\n    Args:\n        save_path (str | None, optional): The path to save the PDB file to.\n            Defaults to `None`.\n        url (str | None, optional): The URL to fetch the PDB file from.\n            Defaults to `None`, in which case the AlphaFold database is used.\n\n    Raises:\n        Exception: If the response status code is not 200, meaning we could\n            not fetch the PDB from the database.\"\"\"\n    if not url:\n        url = f\"https://alphafold.ebi.ac.uk/files/AF-{self.data['entry']}-F1-model_v4.pdb\"\n    if not save_path:\n        save_path = f\"{self.data['entry']}.pdb\"\n\n    response = requests.get(url)\n\n    if response.status_code != 200:\n        raise Exception(f\"Failed to fetch PDB: {response.status_code}\")\n\n    with open(save_path, \"wb+\") as f:\n        f.write(response.content)\n\n    self.pdb_location_relative = save_path\n    self.pdb_location_absolute = os.path.abspath(save_path)\n</code></pre>"},{"location":"api/#procaliper.Protein.from_uniprot_id","title":"<code>from_uniprot_id(uniprot_id, fields=None, from_db='UniProtKB_AC-ID', to_db='UniProtKB-Swiss-Prot')</code>  <code>classmethod</code>","text":"<p>Create a new Protein object from a Uniprot ID (fetches with Uniprot API)</p> <p>Parameters:</p> Name Type Description Default <code>uniprot_id</code> <code>str</code> <p>The Uniprot ID of the protein.</p> required <code>fields</code> <code>list[str] | None</code> <p>The fields to retrieve from Uniprot. If <code>None</code>, <code>Protein.UNIPROT_API_DEFAULT_FIELDS</code> is used.</p> <code>None</code> <code>from_db</code> <code>str</code> <p>The database to retrieve the ID from. Defaults to \"UniProtKB_AC-ID\".</p> <code>'UniProtKB_AC-ID'</code> <code>to_db</code> <code>str</code> <p>The database to map to. Defaults to \"UniProtKB-Swiss-Prot\".</p> <code>'UniProtKB-Swiss-Prot'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If we cannot retrieve the Uniprot ID.</p> <p>Returns:</p> Name Type Description <code>Protein</code> <code>Protein</code> <p>A processed and standardized protein object.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>@classmethod\ndef from_uniprot_id(\n    cls,\n    uniprot_id: str,\n    fields: list[str] | None = None,\n    from_db: str = \"UniProtKB_AC-ID\",\n    to_db: str = \"UniProtKB-Swiss-Prot\",\n) -&gt; Protein:\n    \"\"\"Create a new Protein object from a Uniprot ID (fetches with Uniprot API)\n\n    Args:\n        uniprot_id (str): The Uniprot ID of the protein.\n        fields (list[str] | None, optional): The fields to retrieve from\n            Uniprot. If `None`, `Protein.UNIPROT_API_DEFAULT_FIELDS` is used.\n        from_db (str, optional): The database to retrieve the ID from.\n            Defaults to \"UniProtKB_AC-ID\".\n        to_db (str, optional): The database to map to.\n            Defaults to \"UniProtKB-Swiss-Prot\".\n\n    Raises:\n        ValueError: If we cannot retrieve the Uniprot ID.\n\n    Returns:\n        Protein: A processed and standardized protein object.\n    \"\"\"\n\n    if not fields:\n        fields = cls.UNIPROT_API_DEFAULT_FIELDS\n\n    mapper = ProtMapper()\n\n    result, error = mapper.get(\n        ids=[uniprot_id], fields=fields, from_db=from_db, to_db=to_db\n    )\n    if error:\n        raise ValueError(f\"Uniprot id not retrieved: {error}\")\n    result.rename(columns={\"From\": \"entry\"}, inplace=True)\n    if \"Length\" in result.columns:\n        result[\"Length\"] = pd.to_numeric(result[\"Length\"])\n    return cls.from_uniprot_row(result.iloc[0].to_dict())\n</code></pre>"},{"location":"api/#procaliper.Protein.from_uniprot_row","title":"<code>from_uniprot_row(row)</code>  <code>classmethod</code>","text":"<p>Create a new Protein object from a row from a Uniprot table</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>dict[str, Any]</code> <p>Contains the data from the Uniprot table. Must have \"Sequence\" or \"sequence\" as a key.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If \"Sequence\" or \"sequence\" is not found in the row.</p> <p>Returns:</p> Name Type Description <code>Protein</code> <code>Protein</code> <p>A processed and standardized protein object.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>@classmethod\ndef from_uniprot_row(cls, row: dict[str, Any]) -&gt; Protein:\n    \"\"\"Create a new Protein object from a row from a Uniprot table\n\n    Args:\n        row (dict[str, Any]): Contains the data from the Uniprot table. Must\n            have \"Sequence\" or \"sequence\" as a key.\n\n    Raises:\n        ValueError: If \"Sequence\" or \"sequence\" is not found in the row.\n\n    Returns:\n        Protein: A processed and standardized protein object.\n    \"\"\"\n    p = cls()\n    if \"Sequence\" in row:\n        p.data[\"sequence\"] = row[\"Sequence\"]\n    elif \"sequence\" in row:\n        p.data[\"sequence\"] = row[\"sequence\"]\n    else:\n        raise ValueError(f\"Sequence not found in row: {row}\")\n    p.custom_site_data.add_residue_numbers(len(p.data[\"sequence\"]))\n    p.site_annotations = SiteAnnotations(p.data[\"sequence\"])\n    for key, value in row.items():\n        key = p._rectify_label(key)\n        if key in cls.UNIPROT_SITE_PATTERNS_RECTIFIED:\n            uniprot_description_id = cls.UNIPROT_SITE_PATTERNS_RECTIFIED[key]\n            p.site_annotations.extract_annotation(uniprot_description_id, value)\n        elif key in cls.UNIPROT_SITE_PATTERNS:\n            uniprot_description_id = cls.UNIPROT_SITE_PATTERNS[key]\n            p.site_annotations.extract_annotation(uniprot_description_id, value)\n        else:\n            if value != value:\n                value = \"\"\n            p.data[key] = value\n    return p\n</code></pre>"},{"location":"api/#procaliper.Protein.get_biopandas_pdb_dataframe","title":"<code>get_biopandas_pdb_dataframe()</code>","text":"<p>Get the PDB dataframe for the protein.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Name Type Description <code>PandasPdb</code> <code>PandasPdb</code> <p>A biopandas dataframe that contains the PDB file information.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_biopandas_pdb_dataframe(self) -&gt; PandasPdb:\n    \"\"\"Get the PDB dataframe for the protein.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `pdb_location_absolute` is not set.\n\n    Returns:\n        PandasPdb: A biopandas dataframe that contains the PDB file information.\n    \"\"\"\n    if not self.pdb_location_absolute:\n        raise ValueError(\"PDB location not set; use `fetch_pdb` first\")\n    ppdb = PandasPdb()\n    return ppdb.read_pdb(self.pdb_location_absolute)\n</code></pre>"},{"location":"api/#procaliper.Protein.get_biopython_residues","title":"<code>get_biopython_residues()</code>","text":"<p>Get the biopython residues for the protein.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>list[Residue]</code> <p>list[Residue]: A list of biopython residues for the protein.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_biopython_residues(self) -&gt; list[Residue]:\n    \"\"\"Get the biopython residues for the protein.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `pdb_location_absolute` is not set.\n\n    Returns:\n        list[Residue]: A list of biopython residues for the protein.\n    \"\"\"\n    if not self.pdb_location_absolute:\n        raise ValueError(\"PDB location not set; use `fetch_pdb` first\")\n    p = PDBParser(QUIET=True)\n    structure = p.get_structure(\"\", self.pdb_location_absolute)\n    reslist = [res for model in structure for chain in model for res in chain]\n    return reslist\n</code></pre>"},{"location":"api/#procaliper.Protein.get_biopython_structure","title":"<code>get_biopython_structure()</code>","text":"<p>Get the biopython structure for the protein.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>pdb_location_absolute</code> is not set.</p> <code>ValueError</code> <p>If the PDB file cannot be parsed.</p> <p>Returns:</p> Name Type Description <code>Structure</code> <code>Structure</code> <p>A biopython Structure object for the protein.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_biopython_structure(self) -&gt; Structure:\n    \"\"\"Get the biopython structure for the protein.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `pdb_location_absolute` is not set.\n        ValueError: If the PDB file cannot be parsed.\n\n    Returns:\n        Structure: A biopython Structure object for the protein.\n    \"\"\"\n    if not self.pdb_location_absolute:\n        raise ValueError(\"PDB location not set; use `fetch_pdb` first\")\n    p = PDBParser(QUIET=True)\n    structure = p.get_structure(\"\", self.pdb_location_absolute)\n    if not isinstance(structure, Structure):\n        raise ValueError(\"Unable to parse PDB file.\")\n    return structure\n</code></pre>"},{"location":"api/#procaliper.Protein.get_charge","title":"<code>get_charge(method='gasteiger')</code>","text":"<p>Fetches precomputed charge data for the protein, or computes it.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The method used for the charge calculation. Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to 'gasteiger'. For a full list reference https://open-babel.readthedocs.io/en/latest/Charges/charges.html</p> <code>'gasteiger'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>charge_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>ChargeData</code> <p>structure.charge.ChargeData: A :class:<code>protein_structure.charge.ChargeData</code> object containing the charge values for residues and atoms.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_charge(self, method: str = \"gasteiger\") -&gt; structure.charge.ChargeData:\n    \"\"\"Fetches precomputed charge data for the protein, or computes it.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Args:\n        method (str, optional): The method used for the charge calculation.\n            Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to\n            'gasteiger'. For a full list reference\n            https://open-babel.readthedocs.io/en/latest/Charges/charges.html\n\n    Raises:\n        ValueError: If `charge_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        structure.charge.ChargeData: A :class:`protein_structure.charge.ChargeData`\n            object containing the charge values for residues and atoms.\n    \"\"\"\n    if self.charge_data:\n        if self.charge_data[\"charge_method\"]:\n            if self.charge_data[\"charge_method\"][0] == method:\n                return self.charge_data\n\n    if self.pdb_location_absolute:\n        self.charge_data = structure.charge.calculate_charge(\n            self.pdb_location_absolute,\n            method=method,\n        )\n\n        self.last_charge_method = method\n\n        return self.charge_data\n    else:\n        raise ValueError(\n            \"Charge data for specified method not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_confidence","title":"<code>get_confidence()</code>","text":"<p>Fetches precomputed confidence data from pdb file.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>confidence_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: A list of confidence values for each residue.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_confidence(self) -&gt; list[float]:\n    \"\"\"Fetches precomputed confidence data from pdb file.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `confidence_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        list[float]: A list of confidence values for each residue.\n    \"\"\"\n    if self.confidence_data:\n        return self.confidence_data\n\n    if self.pdb_location_absolute:\n        self.confidence_data = structure.confidence.residue_pLDDT(\n            self.pdb_location_absolute,\n        )\n        return self.confidence_data\n    else:\n        raise ValueError(\n            \"Confidence data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_cysteine_data","title":"<code>get_cysteine_data()</code>","text":"<p>Fetches precomputed size data for the protein, or computes it.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>cysteine_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>CysteineData</code> <p>structure.size.CysteineData: A :class:<code>protein_structure.size.CysteineData</code> object containing the size values for cystein sites.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_cysteine_data(self) -&gt; structure.cysteine_data.CysteineData:\n    \"\"\"Fetches precomputed size data for the protein, or computes it.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `cysteine_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        structure.size.CysteineData: A :class:`protein_structure.size.CysteineData`\n            object containing the size values for cystein sites.\n    \"\"\"\n    if self.cysteine_data:\n        return self.cysteine_data\n\n    if self.pdb_location_absolute:\n        self.cysteine_data = structure.cysteine_data.calculate_cysteine_data(\n            self.pdb_location_absolute,\n        )\n        return self.cysteine_data\n    else:\n        raise ValueError(\n            \"Size data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_sasa","title":"<code>get_sasa()</code>","text":"<p>Fetches precomputed SASA data for the protein, or computes it.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>sasa_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>SASAData</code> <p>structure.sasa.SASAData: A :class:<code>protein_structure.sasa.SASAData</code> object containing the SASA values for residues and atoms.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_sasa(self) -&gt; structure.sasa.SASAData:\n    \"\"\"Fetches precomputed SASA data for the protein, or computes it.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `sasa_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        structure.sasa.SASAData: A :class:`protein_structure.sasa.SASAData`\n            object containing the SASA values for residues and atoms.\n    \"\"\"\n    if self.sasa_data:\n        return self.sasa_data\n\n    if self.pdb_location_absolute:\n        self.sasa_data = structure.sasa.calculate_sasa(\n            self.pdb_location_absolute,\n        )\n        return self.sasa_data\n    else:\n        raise ValueError(\n            \"SASA data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_titration","title":"<code>get_titration()</code>","text":"<p>Runs the default titration calculation for the protein.</p> <p>Equivalent to running <code>self.get_titration_from_propka</code>.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>titration_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>TitrationData</code> <p>structure.titration.TitrationData: A :class:<code>protein_structure.titration.TitrationData</code> object containing the titration values for residues.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_titration(self) -&gt; structure.titration.TitrationData:\n    \"\"\"Runs the default titration calculation for the protein.\n\n    Equivalent to running `self.get_titration_from_propka`.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `titration_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        structure.titration.TitrationData: A\n            :class:`protein_structure.titration.TitrationData` object containing\n            the titration values for residues.\n    \"\"\"\n    return self.get_titration_from_propka()\n</code></pre>"},{"location":"api/#procaliper.Protein.get_titration_from_pkai","title":"<code>get_titration_from_pkai()</code>","text":"<p>Fetches precomputed titration data for the protein, or computes it.</p> <p>Uses :func:<code>protein_structure.titration.calculate_titration_pkai</code> if <code>self.titration_data</code> is not already stored. Requires pkai to be installed. Note that this method is a deep-learning model, not a physics-based calculation.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>titration_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>structure.titration.TitrationData: A</p> Type Description <code>TitrationData</code> <p>the titration values for residues.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_titration_from_pkai(self) -&gt; structure.titration.TitrationData:\n    \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n    Uses :func:`protein_structure.titration.calculate_titration_pkai` if\n    `self.titration_data` is not already stored. Requires pkai to be\n    installed. Note that this method is a deep-learning model, not a\n    physics-based calculation.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `titration_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns: structure.titration.TitrationData: A\n        :class:`protein_structure.titration.TitrationData` object containing\n            the titration values for residues.\"\"\"\n    if self.titration_data:\n        return self.titration_data\n\n    if self.pdb_location_absolute:\n        self.titration_data = structure.titration.calculate_titration_pkai(\n            self.pdb_location_absolute,\n        )\n        return self.titration_data\n    else:\n        raise ValueError(\n            \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_titration_from_propka","title":"<code>get_titration_from_propka()</code>","text":"<p>Fetches precomputed titration data for the protein, or computes it.</p> <p>Uses :func:<code>protein_structure.titration.calculate_titration_propka</code> if <code>self.titration_data</code> is not already stored.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>titration_data</code> is not already stored and <code>pdb_location_absolute</code> is not set.</p> <p>Returns:</p> Type Description <code>TitrationData</code> <p>structure.titration.TitrationData: A :class:<code>protein_structure.titration.TitrationData</code> object containing the titration values for residues.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_titration_from_propka(self) -&gt; structure.titration.TitrationData:\n    \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n    Uses :func:`protein_structure.titration.calculate_titration_propka` if\n    `self.titration_data` is not already stored.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `titration_data` is not already stored and\n            `pdb_location_absolute` is not set.\n\n    Returns:\n        structure.titration.TitrationData: A\n            :class:`protein_structure.titration.TitrationData` object containing\n            the titration values for residues.\"\"\"\n    if self.titration_data:\n        return self.titration_data\n\n    if self.pdb_location_absolute:\n        self.titration_data = structure.titration.calculate_titration_propka(\n            self.pdb_location_absolute,\n        )\n        return self.titration_data\n    else:\n        raise ValueError(\n            \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.get_titration_from_pypka","title":"<code>get_titration_from_pypka()</code>","text":"<p>Fetches precomputed titration data for the protein, or computes it.</p> <p>Uses :func:<code>protein_structure.titration.calculate_titration_pypka</code> if <code>self.titration_data</code> is not already stored. Requires pypka to be installed, which has dependencies that are not FOSS. Please be sure to verify that you are legally allowed to use pypka.</p> <p>Must run <code>self.fetch_pdb</code> first or specify an abosulute path to the PDB file in <code>self.pdb_location_absolute</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>titration_data</code> is not already stored and <code>pdb_location_absolute</code> is not set. ImportError: If pypka is not installed.</p> <p>Returns:</p> Type Description <code>TitrationData</code> <p>structure.titration.TitrationData: A :class:<code>protein_structure.titration.TitrationData</code> object containing the titration values forresidues.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def get_titration_from_pypka(self) -&gt; structure.titration.TitrationData:\n    \"\"\"Fetches precomputed titration data for the protein, or computes it.\n\n    Uses :func:`protein_structure.titration.calculate_titration_pypka` if\n    `self.titration_data` is not already stored. Requires pypka to be\n    installed, which has dependencies that are not FOSS. Please be sure to\n    verify that you are legally allowed to use pypka.\n\n    Must run `self.fetch_pdb` first or specify an abosulute path to the PDB\n    file in `self.pdb_location_absolute`.\n\n    Raises:\n        ValueError: If `titration_data` is not already stored and\n            `pdb_location_absolute` is not set. ImportError: If pypka is not\n            installed.\n\n    Returns:\n        structure.titration.TitrationData: A\n            :class:`protein_structure.titration.TitrationData` object containing\n            the titration values forresidues.\"\"\"\n\n    if self.titration_data:\n        return self.titration_data\n\n    if self.pdb_location_absolute:\n        self.titration_data = structure.titration.calculate_titration_pypka(\n            self.pdb_location_absolute,\n        )\n        return self.titration_data\n    else:\n        raise ValueError(\n            \"Titration data not stored, and PDB location not set; use `fetch_pdb` first\"\n        )\n</code></pre>"},{"location":"api/#procaliper.Protein.list_from_uniprot_ids","title":"<code>list_from_uniprot_ids(uniprot_ids, fields=None, from_db='UniProtKB_AC-ID', to_db='UniProtKB-Swiss-Prot')</code>  <code>classmethod</code>","text":"<p>Create a list of Protein objects from a list of Uniprot IDs (fetches with Uniprot API)</p> <p>Parameters:</p> Name Type Description Default <code>uniprot_ids</code> <code>list[str]</code> <p>The Uniprot IDs of the proteins.</p> required <code>fields</code> <code>list[str] | None</code> <p>The fields to retrieve from Uniprot. If <code>None</code>, <code>Protein.UNIPROT_API_DEFAULT_FIELDS</code> is used.</p> <code>None</code> <code>from_db</code> <code>str</code> <p>The database to retrieve the IDs from. Defaults to \"UniProtKB_AC-ID\".</p> <code>'UniProtKB_AC-ID'</code> <code>to_db</code> <code>str</code> <p>The database to map to. Defaults to \"UniProtKB-Swiss-Prot\".</p> <code>'UniProtKB-Swiss-Prot'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If we cannot retrieve the Uniprot IDs.</p> <p>Returns:</p> Type Description <code>list[Protein]</code> <p>list[Protein]: A list of processed and standardized protein objects.</p> Source code in <code>procaliper/_protein.py</code> <pre><code>@classmethod\ndef list_from_uniprot_ids(\n    cls,\n    uniprot_ids: list[str],\n    fields: list[str] | None = None,\n    from_db: str = \"UniProtKB_AC-ID\",\n    to_db: str = \"UniProtKB-Swiss-Prot\",\n) -&gt; list[Protein]:\n    \"\"\"Create a list of Protein objects from a list of Uniprot IDs (fetches with Uniprot API)\n\n    Args:\n        uniprot_ids (list[str]): The Uniprot IDs of the proteins.\n        fields (list[str] | None, optional): The fields to retrieve from\n            Uniprot. If `None`, `Protein.UNIPROT_API_DEFAULT_FIELDS` is used.\n        from_db (str, optional): The database to retrieve the IDs from.\n            Defaults to \"UniProtKB_AC-ID\".\n        to_db (str, optional): The database to map to.\n            Defaults to \"UniProtKB-Swiss-Prot\".\n\n    Raises:\n        ValueError: If we cannot retrieve the Uniprot IDs.\n\n    Returns:\n        list[Protein]: A list of processed and standardized protein objects.\n    \"\"\"\n    if not fields:\n        fields = cls.UNIPROT_API_DEFAULT_FIELDS\n\n    mapper = ProtMapper()\n\n    result, error = mapper.get(\n        ids=uniprot_ids, fields=fields, from_db=from_db, to_db=to_db\n    )\n    if error:\n        raise ValueError(f\"Uniprot id not retrieved: {error}\")\n    result.rename(columns={\"From\": \"entry\"}, inplace=True)\n\n    if \"Length\" in result.columns:\n        result[\"Length\"] = pd.to_numeric(result[\"Length\"])\n    return [cls.from_uniprot_row(row.to_dict()) for _, row in result.iterrows()]\n</code></pre>"},{"location":"api/#procaliper.Protein.register_local_pdb","title":"<code>register_local_pdb(path_to_pdb_file=None)</code>","text":"<p>Sets pdb file for protein object using local pdb file.</p> <p>Parameters:</p> Name Type Description Default <code>path_to_pdb_file</code> <code>str | None</code> <p>Path to local PDB file. Defaults to <code>None</code>, in which case it assumes a file with 'entry'.pdb.</p> <code>None</code> Source code in <code>procaliper/_protein.py</code> <pre><code>def register_local_pdb(self, path_to_pdb_file: str | None = None) -&gt; None:\n    \"\"\"Sets pdb file for protein object using local pdb file.\n\n    Args:\n        path_to_pdb_file (str | None, optional): Path to local PDB file.\n            Defaults to `None`, in which case it assumes a file with 'entry'.pdb.\"\"\"\n    if not path_to_pdb_file:\n        path_to_pdb_file = f\"{self.data['entry']}.pdb\"\n    self.pdb_location_relative = path_to_pdb_file\n    self.pdb_location_absolute = os.path.abspath(path_to_pdb_file)\n</code></pre>"},{"location":"api/#procaliper.Protein.unravel_sites","title":"<code>unravel_sites(selected_aas=None, selected_keys=None)</code>","text":"<p>Split the protein into individual sites, recording values for each.</p> <p>Parameters:</p> Name Type Description Default <code>selected_aas</code> <code>None | set[AminoAcidLetter]</code> <p>A set of amino acids letters to include in the output. If <code>None</code> (default), all amino acids will be included.</p> <code>None</code> <code>selected_keys</code> <code>None | set[str]</code> <p>A set of keys belonging to this <code>Protein</code> object's <code>data</code> dictionary to include in the output. If <code>None</code> (default), all keys are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, list[Any]]</code> <p>dict[str, list[Any]]: A dictionary mapping keys to lists of values. Each list is a parallel array of the same length as the protein sequence (after filtering out non-selected amino acids).</p> Source code in <code>procaliper/_protein.py</code> <pre><code>def unravel_sites(\n    self,\n    selected_aas: None | set[AminoAcidLetter] = None,\n    selected_keys: None | set[str] = None,\n) -&gt; dict[str, list[Any]]:\n    \"\"\"Split the protein into individual sites, recording values for each.\n\n    Args:\n        selected_aas: A set of amino acids letters to include in the output.\n            If `None` (default), all amino acids will be included.\n        selected_keys: A set of keys belonging to this `Protein` object's\n            `data` dictionary to include in the output. If `None` (default),\n            all keys are used.\n\n    Returns:\n        dict[str, list[Any]]: A dictionary mapping keys to lists of values.\n            Each list is a parallel array of the same length as the protein\n            sequence (after filtering out non-selected amino acids).\"\"\"\n    tbl = self.site_annotations.table() | self.custom_site_data.table()\n    if selected_keys is None:\n        selected_keys = (set(tbl.keys()) | set(self.data.keys())) - {\"sequence\"}\n    tbl_keys = selected_keys &amp; set(tbl.keys())\n    data_keys = selected_keys &amp; set(self.data.keys())\n    assert tbl_keys.isdisjoint(data_keys)\n    res: dict[str, list[Any]] = {k: [] for k in selected_keys}\n    for index, site in enumerate(self.data[\"sequence\"]):\n        if selected_aas and site not in selected_aas:\n            continue\n        for k in tbl_keys:\n            res[k].append(tbl[k][index])\n        for k in data_keys:\n            res[k].append(self.data[k])  # will be the same for all sites\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure","title":"<code>protein_structure</code>","text":""},{"location":"api/#procaliper.protein_structure.calculate_charge","title":"<code>calculate_charge(pdb_filename, method='gasteiger')</code>","text":"<p>Computes the charge of residue sites in a PDB file.</p> <p>By default, the method used is 'gasteiger', but this is configurable in <code>hyperparameters.py</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file. shortname (str): The shortname of the protein (typically will be UniProt ID).</p> required <code>method</code> <code>str</code> <p>The method used for the charge calculation. Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to 'gasteiger'. For a full list reference https://open-babel.readthedocs.io/en/latest/Charges/charges.html</p> <code>'gasteiger'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the charge method is not found.</p> <p>Returns:</p> Name Type Description <code>ChargeData</code> <code>ChargeData</code> <p>A data class for holding charge data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/charge.py</code> <pre><code>def calculate_charge(pdb_filename: str, method: str = \"gasteiger\") -&gt; ChargeData:\n    \"\"\"Computes the charge of residue sites in a PDB file.\n\n    By default, the method used is 'gasteiger', but this is configurable in\n    `hyperparameters.py`.\n\n    Args:\n        pdb_filename (str): The path to the PDB file. shortname (str): The\n            shortname of the protein (typically will be UniProt ID).\n        method (str, optional): The method used for the charge calculation.\n            Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to\n            'gasteiger'. For a full list reference\n            https://open-babel.readthedocs.io/en/latest/Charges/charges.html\n\n\n    Raises:\n        ValueError: If the charge method is not found.\n\n    Returns:\n        ChargeData: A data class for holding charge data from computed from a\n            PDB file.\n    \"\"\"\n    pbmol = next(pybel.readfile(\"pdb\", pdb_filename))\n    mol = pbmol.OBMol\n\n    # Applies the model and computes charges.\n    ob_charge_model = ob.OBChargeModel.FindType(method)\n\n    if not ob_charge_model:\n        raise ValueError(\"Charge method not found. Please check hyperparameters.py\")\n    ob_charge_model.ComputeCharges(mol)\n\n    charges = cast(list[float], ob_charge_model.GetPartialCharges())\n\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)\n\n    # Set up dict\n    res = ChargeData(\n        {\n            \"charge\": [],\n            \"charge_method\": [],\n        }\n    )\n\n    for _, residue in sorted(ppdb.df[\"ATOM\"].groupby(\"residue_number\")):\n        res[\"charge\"].append([charges[x - 1] for x in sorted(residue[\"atom_number\"])])\n        res[\"charge_method\"].append(method)\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.calculate_cysteine_data","title":"<code>calculate_cysteine_data(pdb_filename)</code>","text":"<p>Calculates spatial data for a protein from a PDB file.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Name Type Description <code>CysteineData</code> <code>CysteineData</code> <p>A data class for holding size data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/cysteine_data.py</code> <pre><code>def calculate_cysteine_data(pdb_filename: str) -&gt; CysteineData:\n    \"\"\"Calculates spatial data for a protein from a PDB file.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        CysteineData: A data class for holding size data from computed from a PDB file.\n    \"\"\"\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)\n\n    res = CysteineData(\n        {\n            \"cys_ratio\": [],\n            \"min_dist_to_closest_sulfur\": [],\n            \"sulfur_closeness_rating_scaled\": [],\n        }\n    )\n\n    total_residue = cast(int, max(ppdb.df[\"ATOM\"][\"residue_number\"]))\n\n    cys_positions: list[tuple[float, float, float]] = []\n    for x in range(len(ppdb.df[\"ATOM\"])):\n        if ppdb.df[\"ATOM\"][\"residue_name\"][x] == \"CYS\":\n            if ppdb.df[\"ATOM\"][\"atom_name\"][x] == \"SG\":\n                cys_positions.append(\n                    (\n                        ppdb.df[\"ATOM\"][\"x_coord\"][x],\n                        ppdb.df[\"ATOM\"][\"y_coord\"][x],\n                        ppdb.df[\"ATOM\"][\"z_coord\"][x],\n                    )\n                )\n    total_cys_sites = len(cys_positions)\n\n    cys_index = 0\n\n    for _, grp in sorted(ppdb.df[\"ATOM\"].groupby(\"residue_number\")):\n        if grp[\"residue_name\"].max() == \"CYS\":\n            sg_closeness_rating_scaled = 0\n            x_p, y_p, z_p = cys_positions[cys_index]\n            min_distance = 1000  # Initialize with a large number\n\n            points_excluding_index = (\n                cys_positions[:cys_index] + cys_positions[cys_index + 1 :]\n            )\n            for point in points_excluding_index:\n                x_q, y_q, z_q = point\n                distance = np.sqrt(\n                    (x_p - x_q) ** 2 + (y_p - y_q) ** 2 + (z_p - z_q) ** 2\n                )\n                if distance &lt; min_distance:\n                    min_distance = distance\n                sg_closeness_rating_scaled += 10 / ((distance + 1) ** 2)\n\n            cys_index += 1\n\n            res[\"cys_ratio\"].append(float(total_cys_sites) / float(total_residue))\n            res[\"min_dist_to_closest_sulfur\"].append(min_distance)\n            res[\"sulfur_closeness_rating_scaled\"].append(sg_closeness_rating_scaled)\n        else:\n            res[\"cys_ratio\"].append(None)\n            res[\"min_dist_to_closest_sulfur\"].append(None)\n            res[\"sulfur_closeness_rating_scaled\"].append(None)\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.calculate_sasa","title":"<code>calculate_sasa(pdb_filename)</code>","text":"<p>Compute the SASA values for all CYS sites in a PDB file.</p> <p>Uses the ShrakeRupley algorithm implemented in <code>Bio.PDB.SASA.ShrakeRupley</code> with a probe radius of 1.40 and 100 points.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Name Type Description <code>SASAData</code> <code>SASAData</code> <p>A data class for holding SASA data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/sasa.py</code> <pre><code>def calculate_sasa(pdb_filename: str) -&gt; SASAData:\n    \"\"\"Compute the SASA values for all CYS sites in a PDB file.\n\n    Uses the ShrakeRupley algorithm implemented in `Bio.PDB.SASA.ShrakeRupley`\n    with a probe radius of 1.40 and 100 points.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        SASAData: A data class for holding SASA data from computed from a PDB\n            file.\"\"\"\n    p = PDBParser(QUIET=True)\n    struct = p.get_structure(\"\", pdb_filename)\n\n    sr = ShrakeRupley(probe_radius=PROBE_RADIUS, n_points=N_POINTS, radii_dict=None)\n\n    # Calc sasa values from Residues (from atoms)\n    sr.compute(struct, level=\"R\")\n\n    # Set up dict\n    res = SASAData(\n        {\n            \"all_sasa_value\": [],\n            \"atom_sasa_values\": [],\n        }\n    )\n\n    assert isinstance(struct, Structure)\n    assert struct is not None\n\n    # Fill dict with CYS sites\n    for x in struct.child_list:\n        for y in x.child_list:\n            for z in y.child_list:\n                assert hasattr(z, \"sasa\")\n                res[\"all_sasa_value\"].append(z.sasa)\n                res[\"atom_sasa_values\"].append([zx.sasa for zx in z.child_list])  # type: ignore\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.residue_pLDDT","title":"<code>residue_pLDDT(pdb_filename)</code>","text":"<p>Extracts the pLDDT confidence for each residue in a PDB file.</p> <p>We assume that the pLDDT confidences are in the B-factor entries of the PDB file. If this information is provided at the atom-level, the maximimum value across the residue is used.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: The pLDDT confidence for each residue in the PDB file.</p> Source code in <code>procaliper/protein_structure/confidence.py</code> <pre><code>def residue_pLDDT(pdb_filename: str) -&gt; list[float]:\n    \"\"\"Extracts the pLDDT confidence for each residue in a PDB file.\n\n    We assume that the pLDDT confidences are in the B-factor entries of the PDB\n    file. If this information is provided at the atom-level, the maximimum value\n    across the residue is used.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        list[float]: The pLDDT confidence for each residue in the PDB file.\n    \"\"\"\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)\n\n    vals = []\n    for _, res in ppdb.df[\"ATOM\"].groupby(\"residue_number\"):\n        vals.append(res[\"b_factor\"].max())\n\n    return vals\n</code></pre>"},{"location":"api/#procaliper.protein_structure.charge","title":"<code>charge</code>","text":""},{"location":"api/#procaliper.protein_structure.charge.ChargeData","title":"<code>ChargeData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>A data class for holding charge data from computed from a PDB file.</p> <p>Array index corresponds to residue number in the PDB. Note that Python arrays are 0-indexed and PDB files are 1-indexed, so Python index 0 corresponds to residue 1.</p> <p>Attributes:</p> Name Type Description <code>charges</code> <code>list[list[float]]</code> <p>The charge value for atoms in the residue, ordered from C-terminus to N-terminus according to standard pdb order. For example, in CYS, the last atom is always the SG sulfur.</p> <code>method</code> <code>list[str]</code> <p>The method used for the charge calculation.</p> <code>residue_number</code> <code>list[int]</code> <p>The residue number for the site.</p> <code>residue_name</code> <code>list[str]</code> <p>The residue name (three-letter amino acid abbreviation) for the sites.</p> Source code in <code>procaliper/protein_structure/charge.py</code> <pre><code>class ChargeData(TypedDict):\n    \"\"\"\n    A data class for holding charge data from computed from a PDB file.\n\n    Array index corresponds to residue number in the PDB. Note that Python\n    arrays are 0-indexed and PDB files are 1-indexed, so Python index 0\n    corresponds to residue 1.\n\n    Attributes:\n        charges (list[list[float]]): The charge value for atoms in the residue,\n            ordered from C-terminus to N-terminus according to standard pdb order.\n            For example, in CYS, the last atom is always the SG sulfur.\n        method (list[str]): The method used for the charge calculation.\n        residue_number (list[int]): The residue number for the site.\n        residue_name (list[str]): The residue name (three-letter amino acid\n            abbreviation) for the sites.\n    \"\"\"\n\n    charge: list[list[float]]\n    charge_method: list[str]\n</code></pre>"},{"location":"api/#procaliper.protein_structure.charge.calculate_charge","title":"<code>calculate_charge(pdb_filename, method='gasteiger')</code>","text":"<p>Computes the charge of residue sites in a PDB file.</p> <p>By default, the method used is 'gasteiger', but this is configurable in <code>hyperparameters.py</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file. shortname (str): The shortname of the protein (typically will be UniProt ID).</p> required <code>method</code> <code>str</code> <p>The method used for the charge calculation. Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to 'gasteiger'. For a full list reference https://open-babel.readthedocs.io/en/latest/Charges/charges.html</p> <code>'gasteiger'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the charge method is not found.</p> <p>Returns:</p> Name Type Description <code>ChargeData</code> <code>ChargeData</code> <p>A data class for holding charge data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/charge.py</code> <pre><code>def calculate_charge(pdb_filename: str, method: str = \"gasteiger\") -&gt; ChargeData:\n    \"\"\"Computes the charge of residue sites in a PDB file.\n\n    By default, the method used is 'gasteiger', but this is configurable in\n    `hyperparameters.py`.\n\n    Args:\n        pdb_filename (str): The path to the PDB file. shortname (str): The\n            shortname of the protein (typically will be UniProt ID).\n        method (str, optional): The method used for the charge calculation.\n            Examples include 'qtpie', 'eem', 'gasteiger'. Defaults to\n            'gasteiger'. For a full list reference\n            https://open-babel.readthedocs.io/en/latest/Charges/charges.html\n\n\n    Raises:\n        ValueError: If the charge method is not found.\n\n    Returns:\n        ChargeData: A data class for holding charge data from computed from a\n            PDB file.\n    \"\"\"\n    pbmol = next(pybel.readfile(\"pdb\", pdb_filename))\n    mol = pbmol.OBMol\n\n    # Applies the model and computes charges.\n    ob_charge_model = ob.OBChargeModel.FindType(method)\n\n    if not ob_charge_model:\n        raise ValueError(\"Charge method not found. Please check hyperparameters.py\")\n    ob_charge_model.ComputeCharges(mol)\n\n    charges = cast(list[float], ob_charge_model.GetPartialCharges())\n\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)\n\n    # Set up dict\n    res = ChargeData(\n        {\n            \"charge\": [],\n            \"charge_method\": [],\n        }\n    )\n\n    for _, residue in sorted(ppdb.df[\"ATOM\"].groupby(\"residue_number\")):\n        res[\"charge\"].append([charges[x - 1] for x in sorted(residue[\"atom_number\"])])\n        res[\"charge_method\"].append(method)\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.confidence","title":"<code>confidence</code>","text":""},{"location":"api/#procaliper.protein_structure.confidence.residue_pLDDT","title":"<code>residue_pLDDT(pdb_filename)</code>","text":"<p>Extracts the pLDDT confidence for each residue in a PDB file.</p> <p>We assume that the pLDDT confidences are in the B-factor entries of the PDB file. If this information is provided at the atom-level, the maximimum value across the residue is used.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: The pLDDT confidence for each residue in the PDB file.</p> Source code in <code>procaliper/protein_structure/confidence.py</code> <pre><code>def residue_pLDDT(pdb_filename: str) -&gt; list[float]:\n    \"\"\"Extracts the pLDDT confidence for each residue in a PDB file.\n\n    We assume that the pLDDT confidences are in the B-factor entries of the PDB\n    file. If this information is provided at the atom-level, the maximimum value\n    across the residue is used.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        list[float]: The pLDDT confidence for each residue in the PDB file.\n    \"\"\"\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)\n\n    vals = []\n    for _, res in ppdb.df[\"ATOM\"].groupby(\"residue_number\"):\n        vals.append(res[\"b_factor\"].max())\n\n    return vals\n</code></pre>"},{"location":"api/#procaliper.protein_structure.cysteine_data","title":"<code>cysteine_data</code>","text":""},{"location":"api/#procaliper.protein_structure.cysteine_data.CysteineData","title":"<code>CysteineData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Data class for holding size data from computed from a PDB file.</p> <p>Non-CYS sites are assigned <code>None</code> values.</p> <p>Array index corresponds to residue number in the PDB. Note that Python arrays are 0-indexed and PDB files are 1-indexed, so Python index 0 corresponds to residue 1.</p> <p>Attributes:</p> Name Type Description <code>cys_ratio</code> <code>list[float | None]</code> <p>The ratio of CYS sites to total sites.</p> <code>min_dist_to_closest_sulfur</code> <code>list[float | None]</code> <p>The minimum distance to the closest sulfur for each CYS site.</p> <code>sulfur_closeness_rating_scaled</code> <code>list[float | None]</code> <p>The sulfur closeness rating scaled for the CYS sites.</p> Source code in <code>procaliper/protein_structure/cysteine_data.py</code> <pre><code>class CysteineData(TypedDict):\n    \"\"\"Data class for holding size data from computed from a PDB file.\n\n    Non-CYS sites are assigned `None` values.\n\n    Array index corresponds to residue number in the PDB. Note that Python\n    arrays are 0-indexed and PDB files are 1-indexed, so Python index 0\n    corresponds to residue 1.\n\n    Attributes:\n        cys_ratio (list[float | None]): The ratio of CYS sites to total sites.\n        min_dist_to_closest_sulfur (list[float | None]): The minimum distance to the closest sulfur for each CYS site.\n        sulfur_closeness_rating_scaled (list[float | None]): The sulfur closeness rating scaled for the CYS sites.\"\"\"\n\n    cys_ratio: list[float | None]\n    min_dist_to_closest_sulfur: list[float | None]\n    sulfur_closeness_rating_scaled: list[float | None]\n</code></pre>"},{"location":"api/#procaliper.protein_structure.cysteine_data.calculate_cysteine_data","title":"<code>calculate_cysteine_data(pdb_filename)</code>","text":"<p>Calculates spatial data for a protein from a PDB file.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Name Type Description <code>CysteineData</code> <code>CysteineData</code> <p>A data class for holding size data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/cysteine_data.py</code> <pre><code>def calculate_cysteine_data(pdb_filename: str) -&gt; CysteineData:\n    \"\"\"Calculates spatial data for a protein from a PDB file.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        CysteineData: A data class for holding size data from computed from a PDB file.\n    \"\"\"\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)\n\n    res = CysteineData(\n        {\n            \"cys_ratio\": [],\n            \"min_dist_to_closest_sulfur\": [],\n            \"sulfur_closeness_rating_scaled\": [],\n        }\n    )\n\n    total_residue = cast(int, max(ppdb.df[\"ATOM\"][\"residue_number\"]))\n\n    cys_positions: list[tuple[float, float, float]] = []\n    for x in range(len(ppdb.df[\"ATOM\"])):\n        if ppdb.df[\"ATOM\"][\"residue_name\"][x] == \"CYS\":\n            if ppdb.df[\"ATOM\"][\"atom_name\"][x] == \"SG\":\n                cys_positions.append(\n                    (\n                        ppdb.df[\"ATOM\"][\"x_coord\"][x],\n                        ppdb.df[\"ATOM\"][\"y_coord\"][x],\n                        ppdb.df[\"ATOM\"][\"z_coord\"][x],\n                    )\n                )\n    total_cys_sites = len(cys_positions)\n\n    cys_index = 0\n\n    for _, grp in sorted(ppdb.df[\"ATOM\"].groupby(\"residue_number\")):\n        if grp[\"residue_name\"].max() == \"CYS\":\n            sg_closeness_rating_scaled = 0\n            x_p, y_p, z_p = cys_positions[cys_index]\n            min_distance = 1000  # Initialize with a large number\n\n            points_excluding_index = (\n                cys_positions[:cys_index] + cys_positions[cys_index + 1 :]\n            )\n            for point in points_excluding_index:\n                x_q, y_q, z_q = point\n                distance = np.sqrt(\n                    (x_p - x_q) ** 2 + (y_p - y_q) ** 2 + (z_p - z_q) ** 2\n                )\n                if distance &lt; min_distance:\n                    min_distance = distance\n                sg_closeness_rating_scaled += 10 / ((distance + 1) ** 2)\n\n            cys_index += 1\n\n            res[\"cys_ratio\"].append(float(total_cys_sites) / float(total_residue))\n            res[\"min_dist_to_closest_sulfur\"].append(min_distance)\n            res[\"sulfur_closeness_rating_scaled\"].append(sg_closeness_rating_scaled)\n        else:\n            res[\"cys_ratio\"].append(None)\n            res[\"min_dist_to_closest_sulfur\"].append(None)\n            res[\"sulfur_closeness_rating_scaled\"].append(None)\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.distance","title":"<code>distance</code>","text":""},{"location":"api/#procaliper.protein_structure.distance.contact_map","title":"<code>contact_map(structure, max_dist_angsrtom=10)</code>","text":"<p>A contact map for a protein structure.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>protein structure.</p> required <code>max_dist_angsrtom</code> <code>float</code> <p>Largest distance to consider a contact, in Angstroms. Defaults to 10.</p> <code>10</code> <p>Returns:</p> Type Description <code>NDArray[int8]</code> <p>npt.NDArray[np.float64]: contact map with shape nxn where n is the number of residues in the structure.</p> Source code in <code>procaliper/protein_structure/distance.py</code> <pre><code>def contact_map(\n    structure: Structure, max_dist_angsrtom: float = 10\n) -&gt; npt.NDArray[np.int8]:\n    \"\"\"A contact map for a protein structure.\n\n    Args:\n        structure (Structure): protein structure.\n        max_dist_angsrtom (float, optional): Largest distance to consider a contact,\n            in Angstroms. Defaults to 10.\n\n    Returns:\n        npt.NDArray[np.float64]: contact map with shape nxn where n is the\n            number of residues in the structure.\n    \"\"\"\n    residues = [res for model in structure for chain in model for res in chain]\n    residues = list(enumerate(residues))\n    adj = np.zeros((len(residues), len(residues)), dtype=np.int8)\n\n    # a residue has zero distance to itself\n    for i in range(len(residues)):\n        adj[i, i] = np.int8(1)\n\n    for (row, r1), (col, r2) in combinations(residues, 2):\n        dist = residue_distance(r1, r2)\n        if dist &lt;= max_dist_angsrtom:\n            adj[row, col] = np.int8(1)\n            adj[col, row] = np.int8(1)\n    return adj\n</code></pre>"},{"location":"api/#procaliper.protein_structure.distance.distance_matrix","title":"<code>distance_matrix(structure, thresh=np.inf)</code>","text":"<p>Compute a distance matrix for a protein structure.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>protein structure.</p> required <code>thresh</code> <code>float</code> <p>threshold for distance. Defaults to np.inf. Distances greater than this will be set to np.inf.</p> <code>inf</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>npt.NDArray[np.float64]: distance matrix with shape nxn where n is the number of residues in the structure.</p> Source code in <code>procaliper/protein_structure/distance.py</code> <pre><code>def distance_matrix(\n    structure: Structure, thresh: float = np.inf\n) -&gt; npt.NDArray[np.float64]:\n    \"\"\"Compute a distance matrix for a protein structure.\n\n    Args:\n        structure (Structure): protein structure.\n        thresh (float, optional): threshold for distance. Defaults to np.inf.\n            Distances greater than this will be set to np.inf.\n\n    Returns:\n        npt.NDArray[np.float64]: distance matrix with shape nxn where n is the\n            number of residues in the structure.\n    \"\"\"\n    residues = [res for model in structure for chain in model for res in chain]\n    residues = list(enumerate(residues))\n    adj = np.ones((len(residues), len(residues))) * np.inf\n\n    # a residue has zero distance to itself\n    for i in range(len(residues)):\n        adj[i, i] = 0\n\n    for (row, r1), (col, r2) in combinations(residues, 2):\n        dist = residue_distance(r1, r2)\n        if dist &lt;= thresh:\n            adj[row, col] = dist\n            adj[col, row] = adj[row, col]\n    return adj\n</code></pre>"},{"location":"api/#procaliper.protein_structure.distance.proximity_matrix","title":"<code>proximity_matrix(structure, thresh=0)</code>","text":"<p>Compute a proximity matrix for a protein structure.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>protein structure.</p> required <code>thresh</code> <code>float</code> <p>threshold for proximity. Defaults to 0. Proximity less than this will be set to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>npt.NDArray[np.float64]: proximity matrix with shape nxn where n is the number of residues in the structure.</p> Source code in <code>procaliper/protein_structure/distance.py</code> <pre><code>def proximity_matrix(\n    structure: Structure, thresh: float = 0\n) -&gt; npt.NDArray[np.float64]:\n    \"\"\"Compute a proximity matrix for a protein structure.\n\n    Args:\n        structure (Structure): protein structure.\n        thresh (float, optional): threshold for proximity. Defaults to 0. Proximity\n            less than this will be set to 0.\n\n    Returns:\n        npt.NDArray[np.float64]: proximity matrix with shape nxn where n is the\n            number of residues in the structure.\n    \"\"\"\n    residues = [res for model in structure for chain in model for res in chain]\n    residues = list(enumerate(residues))\n    adj = np.zeros((len(residues), len(residues)))\n\n    # a residue has proximity 1 to itself\n    for i in range(len(residues)):\n        adj[i, i] = 1\n\n    for (row, r1), (col, r2) in combinations(residues, 2):\n        prox = 1 / (residue_distance(r1, r2) + 1)\n        if prox &gt;= thresh:\n            adj[row, col] = prox\n            adj[col, row] = adj[row, col]\n    return adj\n</code></pre>"},{"location":"api/#procaliper.protein_structure.distance.region_distance","title":"<code>region_distance(region_1, region_2)</code>","text":"<p>Compute the distance between two regions of a protein, in Angstroms.</p> <p>Parameters:</p> Name Type Description Default <code>region_1</code> <code>Iterable[Residue]</code> <p>first region.</p> required <code>region_2</code> <code>Iterable[Residue]</code> <p>second region.</p> required <p>Returns:</p> Type Description <code>floating[Any]</code> <p>np.floating[Any]: minimum distance between the two regions.</p> Source code in <code>procaliper/protein_structure/distance.py</code> <pre><code>def region_distance(\n    region_1: Iterable[Residue], region_2: Iterable[Residue]\n) -&gt; np.floating[Any]:\n    \"\"\"Compute the distance between two regions of a protein, in Angstroms.\n\n    Args:\n        region_1 (Iterable[Residue]): first region.\n        region_2 (Iterable[Residue]): second region.\n\n    Returns:\n        np.floating[Any]: minimum distance between the two regions.\n    \"\"\"\n    return min(residue_distance(r1, r2) for r1, r2 in product(region_1, region_2))\n</code></pre>"},{"location":"api/#procaliper.protein_structure.distance.region_distance_matrix","title":"<code>region_distance_matrix(regions)</code>","text":"<p>Compute a distance matrix between regions of a protein.</p> <p>Parameters:</p> Name Type Description Default <code>regions</code> <code>Sequence[Iterable[Residue]]</code> <p>sequence of regions; each region is an iterable of residues.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>npt.NDArray[np.float64]: distance matrix with shape nxn where n is the number of regions.</p> Source code in <code>procaliper/protein_structure/distance.py</code> <pre><code>def region_distance_matrix(\n    regions: Sequence[Iterable[Residue]],\n) -&gt; npt.NDArray[np.float64]:\n    \"\"\"Compute a distance matrix between regions of a protein.\n\n    Args:\n        regions (Sequence[Iterable[Residue]]): sequence of regions; each region is an iterable of residues.\n\n    Returns:\n        npt.NDArray[np.float64]: distance matrix with shape nxn where n is the\n            number of regions.\n    \"\"\"\n    return np.array([[region_distance(r1, r2) for r2 in regions] for r1 in regions])\n</code></pre>"},{"location":"api/#procaliper.protein_structure.distance.residue_distance","title":"<code>residue_distance(r1, r2)</code>","text":"<p>Compute the distance between two residues, in Angstroms.</p> <p>Parameters:</p> Name Type Description Default <code>r1</code> <code>Residue</code> <p>first residue.</p> required <code>r2</code> <code>Residue</code> <p>second residue.</p> required <p>Returns:</p> Type Description <code>floating[Any]</code> <p>np.floating[Any]: distance between the two residues.</p> Source code in <code>procaliper/protein_structure/distance.py</code> <pre><code>def residue_distance(\n    r1: Residue,\n    r2: Residue,\n) -&gt; np.floating[Any]:\n    \"\"\"Compute the distance between two residues, in Angstroms.\n\n    Args:\n        r1 (Residue): first residue.\n        r2 (Residue): second residue.\n\n    Returns:\n        np.floating[Any]: distance between the two residues.\n    \"\"\"\n    dv = r1[\"CA\"].coord - r2[\"CA\"].coord\n    return np.linalg.norm(dv)\n</code></pre>"},{"location":"api/#procaliper.protein_structure.sasa","title":"<code>sasa</code>","text":""},{"location":"api/#procaliper.protein_structure.sasa.SASAData","title":"<code>SASAData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Data class for holding SASA data from computed from a PDB file.</p> <p>Array index corresponds to residue number in the PDB. Note that Python arrays are 0-indexed and PDB files are 1-indexed, so Python index 0 corresponds to residue 1.</p> <p>Attributes:</p> Name Type Description <code>all_sasa_value</code> <code>list[float]</code> <p>The overall SASA value for each site (computed as sum of atom SASA values).</p> <code>atom_sasa_values</code> <code>list[list[float]]</code> <p>The SASA value for the each atom in each sites. Atoms are ordered from C-terminus to N-terminus according to standard pdb order. For example, in CYS, the last atom is always the SG sulfur.</p> Source code in <code>procaliper/protein_structure/sasa.py</code> <pre><code>class SASAData(TypedDict):\n    \"\"\"Data class for holding SASA data from computed from a PDB file.\n\n    Array index corresponds to residue number in the PDB. Note that Python\n    arrays are 0-indexed and PDB files are 1-indexed, so Python index 0\n    corresponds to residue 1.\n\n    Attributes:\n        all_sasa_value (list[float]): The overall SASA value for each site\n            (computed as sum of atom SASA values).\n        atom_sasa_values (list[list[float]]): The SASA value for the each atom\n            in each sites. Atoms are ordered from C-terminus to N-terminus\n            according to standard pdb order. For example, in CYS, the last atom\n            is always the SG sulfur.\n    \"\"\"\n\n    all_sasa_value: list[float]\n    atom_sasa_values: list[list[float]]\n</code></pre>"},{"location":"api/#procaliper.protein_structure.sasa.calculate_sasa","title":"<code>calculate_sasa(pdb_filename)</code>","text":"<p>Compute the SASA values for all CYS sites in a PDB file.</p> <p>Uses the ShrakeRupley algorithm implemented in <code>Bio.PDB.SASA.ShrakeRupley</code> with a probe radius of 1.40 and 100 points.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Name Type Description <code>SASAData</code> <code>SASAData</code> <p>A data class for holding SASA data from computed from a PDB file.</p> Source code in <code>procaliper/protein_structure/sasa.py</code> <pre><code>def calculate_sasa(pdb_filename: str) -&gt; SASAData:\n    \"\"\"Compute the SASA values for all CYS sites in a PDB file.\n\n    Uses the ShrakeRupley algorithm implemented in `Bio.PDB.SASA.ShrakeRupley`\n    with a probe radius of 1.40 and 100 points.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        SASAData: A data class for holding SASA data from computed from a PDB\n            file.\"\"\"\n    p = PDBParser(QUIET=True)\n    struct = p.get_structure(\"\", pdb_filename)\n\n    sr = ShrakeRupley(probe_radius=PROBE_RADIUS, n_points=N_POINTS, radii_dict=None)\n\n    # Calc sasa values from Residues (from atoms)\n    sr.compute(struct, level=\"R\")\n\n    # Set up dict\n    res = SASAData(\n        {\n            \"all_sasa_value\": [],\n            \"atom_sasa_values\": [],\n        }\n    )\n\n    assert isinstance(struct, Structure)\n    assert struct is not None\n\n    # Fill dict with CYS sites\n    for x in struct.child_list:\n        for y in x.child_list:\n            for z in y.child_list:\n                assert hasattr(z, \"sasa\")\n                res[\"all_sasa_value\"].append(z.sasa)\n                res[\"atom_sasa_values\"].append([zx.sasa for zx in z.child_list])  # type: ignore\n\n    return res\n</code></pre>"},{"location":"api/#procaliper.protein_structure.titration","title":"<code>titration</code>","text":""},{"location":"api/#procaliper.protein_structure.titration.TitrationData","title":"<code>TitrationData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Data class for titration data.</p> <p>Array index corresponds to residue number in the PDB. Note that Python arrays are 0-indexed and PDB files are 1-indexed, so Python index 0 corresponds to residue 1.</p> <p>Attributes:</p> Name Type Description <code>pKa</code> <code>list[float | None]</code> <p>The pKa values for the titration data. Non-titratable sites are assigned <code>None</code> values. protonation_state</p> <code>(list[tuple[str,</code> <code>float]]</code> <p>The expected protonation states for the titration data. The first element of the tuple is the state of the site and the second element is the average protonation of the site. Non-titratable sites are assigned <code>(\"undefined\", nan)</code>.</p> Source code in <code>procaliper/protein_structure/titration.py</code> <pre><code>class TitrationData(TypedDict):\n    \"\"\"Data class for titration data.\n\n    Array index corresponds to residue number in the PDB. Note that Python\n    arrays are 0-indexed and PDB files are 1-indexed, so Python index 0\n    corresponds to residue 1.\n\n    Attributes:\n        pKa (list[float | None]): The pKa values for the titration data.\n            Non-titratable sites are assigned `None` values. protonation_state\n        (list[tuple[str, float]]): The expected protonation states for the\n            titration data. The first element of the tuple is the state of the\n            site and the second element is the average protonation of the site.\n            Non-titratable sites are assigned `(\"undefined\", nan)`.\n    \"\"\"\n\n    pKa: list[float | None]\n    protonation_state: list[tuple[str, float | str]]\n</code></pre>"},{"location":"api/#procaliper.protein_structure.titration.calculate_titration_propka","title":"<code>calculate_titration_propka(pdb_filename)</code>","text":"<p>Uses propka to calculate titration data for the protein.</p> <p>Parameters:</p> Name Type Description Default <code>pdb_filename</code> <code>str</code> <p>The path to the PDB file.</p> required <p>Returns:</p> Name Type Description <code>TitrationData</code> <code>TitrationData</code> <p>The titration data for the protein.</p> Source code in <code>procaliper/protein_structure/titration.py</code> <pre><code>def calculate_titration_propka(pdb_filename: str) -&gt; TitrationData:\n    \"\"\"Uses propka to calculate titration data for the protein.\n\n    Args:\n        pdb_filename (str): The path to the PDB file.\n\n    Returns:\n        TitrationData: The titration data for the protein.\n    \"\"\"\n    mol = propka.run.single(pdb_filename, optargs=[\"--quiet\"], write_pka=False)\n    gs = mol.conformations[\"AVR\"].groups\n\n    ppdb = PandasPdb()\n    ppdb.read_pdb(pdb_filename)\n\n    seq = {\n        i: res[\"residue_name\"].iloc[0]\n        for i, res in ppdb.df[\"ATOM\"].groupby(\"residue_number\")\n    }\n    pks = {group.atom.res_num: group.pka_value for group in gs}\n    sv = sorted(seq.items())\n    return TitrationData(\n        # pKa=[group.pka_value for group in gs],\n        pKa=[pks[i] if i in pks else None for i, _ in sv],\n        protonation_state=[_state_from_pk(pks[i] if i in pks else 0) for i, _ in sv],\n    )\n</code></pre>"},{"location":"api/#procaliper.site_metadata","title":"<code>site_metadata</code>","text":""},{"location":"api/#procaliper.site_metadata.CustomSiteData","title":"<code>CustomSiteData</code>","text":"<p>Class for storing custom site-level data.</p> Source code in <code>procaliper/site_metadata/custom_site_data.py</code> <pre><code>class CustomSiteData:\n    \"\"\"Class for storing custom site-level data.\"\"\"\n\n    def __init__(self, residue_number: list[int], data: dict[str, list[Any]]) -&gt; None:\n        self.residue_number = residue_number\n        for key, value in data.items():\n            setattr(self, key, value)\n\n        self.keys = {\"residue_number\"} | set(data.keys())\n\n    @classmethod\n    def from_dict(\n        cls,\n        data: dict[str, list[Any]],\n        residue_index_feature_name: str = \"residue_number\",\n    ) -&gt; CustomSiteData:\n        \"\"\"Create a CustomSiteData object from a dictionary of data.\n\n        Args:\n            data (dict[str, list[Any]]): Data dictionary indexed by feature\n                name. Each value must be a list of the same length as the\n                residue number feature. Must include a residue number key.\n            residue_index_feature_name (str, optional): The name of the feature\n                that contains the residue number. Defaults to \"residue_number\".\n\n        Raises:\n            ValueError: If the residue number feature is not in the data.\n\n        Returns:\n            CustomSiteData: A CustomSiteData object. that contains the data.\n        \"\"\"\n        if residue_index_feature_name not in data:\n            raise ValueError(\"CustomSiteData must have a residue_number key.\")\n        return cls(data[residue_index_feature_name], data)\n\n    def table(self) -&gt; dict[str, list[Any]]:\n        \"\"\"Return a dictionary of the data in the CustomSiteData object.\n\n        Returns:\n            dict[str, list[Any]]: A dictionary of the data in the CustomSiteData\n                object.\n        \"\"\"\n        return {k: getattr(self, k) for k in self.keys}\n\n    def add_residue_numbers(self, residue_number: list[int] | int) -&gt; None:\n        \"\"\"Specify the number of residues in the CustomSiteData object.\n\n        Args:\n            residue_number (list[int] | int): If an integer, the number of\n                residues. If a list of integers, the list of residue numbers.\n        \"\"\"\n        if isinstance(residue_number, int):\n            self.residue_number = list(range(1, residue_number + 1))\n        else:\n            self.residue_number = residue_number\n\n    def add_site_data(self, key: str, row: list[Any], overwrite: bool = False) -&gt; None:\n        \"\"\"Add a site-level feature to the CustomSiteData object.\n\n        Args:\n            key (str): The name of the feature to add.\n            row (list[Any]): The values for the feature.\n\n            overwrite (bool, optional): Whether to overwrite an existing\n                feature. Defaults to False.\n\n        Raises:\n            KeyError: If overwrite is False and the feature already exists.\n            ValueError: If the number of values in the feature does not match\n                the number of residues.\n        \"\"\"\n        if hasattr(self, key) and not overwrite:\n            raise KeyError(\n                f\"CustomSiteData already has a {key} key and overwrite is False.\"\n            )\n\n        if len(row) != len(self.residue_number):\n            raise ValueError(\n                f\"CustomSiteData has {len(self.residue_number)} residues, but {key} has {len(row)} values.\"\n                \" Perhaps you forgot to call add_residue_numbers?\"\n            )\n\n        setattr(self, key, row)\n        self.keys.add(key)\n</code></pre>"},{"location":"api/#procaliper.site_metadata.CustomSiteData.add_residue_numbers","title":"<code>add_residue_numbers(residue_number)</code>","text":"<p>Specify the number of residues in the CustomSiteData object.</p> <p>Parameters:</p> Name Type Description Default <code>residue_number</code> <code>list[int] | int</code> <p>If an integer, the number of residues. If a list of integers, the list of residue numbers.</p> required Source code in <code>procaliper/site_metadata/custom_site_data.py</code> <pre><code>def add_residue_numbers(self, residue_number: list[int] | int) -&gt; None:\n    \"\"\"Specify the number of residues in the CustomSiteData object.\n\n    Args:\n        residue_number (list[int] | int): If an integer, the number of\n            residues. If a list of integers, the list of residue numbers.\n    \"\"\"\n    if isinstance(residue_number, int):\n        self.residue_number = list(range(1, residue_number + 1))\n    else:\n        self.residue_number = residue_number\n</code></pre>"},{"location":"api/#procaliper.site_metadata.CustomSiteData.add_site_data","title":"<code>add_site_data(key, row, overwrite=False)</code>","text":"<p>Add a site-level feature to the CustomSiteData object.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the feature to add.</p> required <code>row</code> <code>list[Any]</code> <p>The values for the feature.</p> required <code>overwrite</code> <code>bool</code> <p>Whether to overwrite an existing feature. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If overwrite is False and the feature already exists.</p> <code>ValueError</code> <p>If the number of values in the feature does not match the number of residues.</p> Source code in <code>procaliper/site_metadata/custom_site_data.py</code> <pre><code>def add_site_data(self, key: str, row: list[Any], overwrite: bool = False) -&gt; None:\n    \"\"\"Add a site-level feature to the CustomSiteData object.\n\n    Args:\n        key (str): The name of the feature to add.\n        row (list[Any]): The values for the feature.\n\n        overwrite (bool, optional): Whether to overwrite an existing\n            feature. Defaults to False.\n\n    Raises:\n        KeyError: If overwrite is False and the feature already exists.\n        ValueError: If the number of values in the feature does not match\n            the number of residues.\n    \"\"\"\n    if hasattr(self, key) and not overwrite:\n        raise KeyError(\n            f\"CustomSiteData already has a {key} key and overwrite is False.\"\n        )\n\n    if len(row) != len(self.residue_number):\n        raise ValueError(\n            f\"CustomSiteData has {len(self.residue_number)} residues, but {key} has {len(row)} values.\"\n            \" Perhaps you forgot to call add_residue_numbers?\"\n        )\n\n    setattr(self, key, row)\n    self.keys.add(key)\n</code></pre>"},{"location":"api/#procaliper.site_metadata.CustomSiteData.from_dict","title":"<code>from_dict(data, residue_index_feature_name='residue_number')</code>  <code>classmethod</code>","text":"<p>Create a CustomSiteData object from a dictionary of data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, list[Any]]</code> <p>Data dictionary indexed by feature name. Each value must be a list of the same length as the residue number feature. Must include a residue number key.</p> required <code>residue_index_feature_name</code> <code>str</code> <p>The name of the feature that contains the residue number. Defaults to \"residue_number\".</p> <code>'residue_number'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the residue number feature is not in the data.</p> <p>Returns:</p> Name Type Description <code>CustomSiteData</code> <code>CustomSiteData</code> <p>A CustomSiteData object. that contains the data.</p> Source code in <code>procaliper/site_metadata/custom_site_data.py</code> <pre><code>@classmethod\ndef from_dict(\n    cls,\n    data: dict[str, list[Any]],\n    residue_index_feature_name: str = \"residue_number\",\n) -&gt; CustomSiteData:\n    \"\"\"Create a CustomSiteData object from a dictionary of data.\n\n    Args:\n        data (dict[str, list[Any]]): Data dictionary indexed by feature\n            name. Each value must be a list of the same length as the\n            residue number feature. Must include a residue number key.\n        residue_index_feature_name (str, optional): The name of the feature\n            that contains the residue number. Defaults to \"residue_number\".\n\n    Raises:\n        ValueError: If the residue number feature is not in the data.\n\n    Returns:\n        CustomSiteData: A CustomSiteData object. that contains the data.\n    \"\"\"\n    if residue_index_feature_name not in data:\n        raise ValueError(\"CustomSiteData must have a residue_number key.\")\n    return cls(data[residue_index_feature_name], data)\n</code></pre>"},{"location":"api/#procaliper.site_metadata.CustomSiteData.table","title":"<code>table()</code>","text":"<p>Return a dictionary of the data in the CustomSiteData object.</p> <p>Returns:</p> Type Description <code>dict[str, list[Any]]</code> <p>dict[str, list[Any]]: A dictionary of the data in the CustomSiteData object.</p> Source code in <code>procaliper/site_metadata/custom_site_data.py</code> <pre><code>def table(self) -&gt; dict[str, list[Any]]:\n    \"\"\"Return a dictionary of the data in the CustomSiteData object.\n\n    Returns:\n        dict[str, list[Any]]: A dictionary of the data in the CustomSiteData\n            object.\n    \"\"\"\n    return {k: getattr(self, k) for k in self.keys}\n</code></pre>"},{"location":"api/#procaliper.site_metadata.SiteAnnotations","title":"<code>SiteAnnotations</code>","text":"<p>Class for parsing and storing UniProt site annotations.</p> <p>An example of a UniProt site annotation:</p> <p><code>DISULFID 28..87; /evidence=\"ECO:0000255|PROSITE-ProRule:PRU00114\"; DISULFID 105; /note=\"Interchain (with heavy chain)\"</code></p> <p>Attributes:</p> Name Type Description <code>residue_letter</code> <code>list[str]</code> <p>A list of amino acid letters.</p> <code>residue_number</code> <code>list[int]</code> <p>A list of residue numbers.</p> <code>binding</code> <code>list[bool]</code> <p>A list of booleans indicating whether a residue is a binding site.</p> <code>active</code> <code>list[bool]</code> <p>A list of booleans indicating whether a residue is an active site.</p> <code>dna_binding</code> <code>list[bool]</code> <p>A list of booleans indicating whether a residue is a DNA binding site.</p> <code>disulfide_bond</code> <code>list[bool]</code> <p>A list of booleans indicating whether a residue is a disulfide bond.</p> <code>helix</code> <code>list[bool]</code> <p>A list of booleans indicating whether a residue is in a helix.</p> <code>turn</code> <code>list[bool]</code> <p>A list of booleans indicating whether a residue is in a turn.</p> <code>beta_strand</code> <code>list[bool]</code> <p>A list of booleans indicating whether a residue is in a beta strand.</p> <code>binding_data</code> <code>list[dict[str, str]]</code> <p>A list of dictionaries containing binding site metadata.</p> <code>active_data</code> <code>list[dict[str, str]]</code> <p>A list of dictionaries containing active site metadata.</p> Source code in <code>procaliper/site_metadata/uniprot_site_parsing.py</code> <pre><code>class SiteAnnotations:\n    \"\"\"Class for parsing and storing UniProt site annotations.\n\n    An example of a UniProt site annotation:\n\n    `DISULFID 28..87; /evidence=\"ECO:0000255|PROSITE-ProRule:PRU00114\"; DISULFID 105; /note=\"Interchain (with heavy chain)\"`\n\n    Attributes:\n        residue_letter (list[str]): A list of amino acid letters.\n        residue_number (list[int]): A list of residue numbers.\n        binding (list[bool]): A list of booleans indicating whether a residue\n            is a binding site.\n        active (list[bool]): A list of booleans indicating whether a residue\n            is an active site.\n        dna_binding (list[bool]): A list of booleans indicating whether a residue\n            is a DNA binding site.\n        disulfide_bond (list[bool]): A list of booleans indicating whether a residue\n            is a disulfide bond.\n        helix (list[bool]): A list of booleans indicating whether a residue\n            is in a helix.\n        turn (list[bool]): A list of booleans indicating whether a residue\n            is in a turn.\n        beta_strand (list[bool]): A list of booleans indicating whether a residue\n            is in a beta strand.\n        binding_data (list[dict[str, str]]): A list of dictionaries containing\n            binding site metadata.\n        active_data (list[dict[str, str]]): A list of dictionaries containing\n            active site metadata.\n    \"\"\"\n\n    fields_by_description_type = {\n        \"BINDING\": [\"ligand\"],\n        \"ACT_SITE\": [\"note\"],\n        \"DNA_BIND\": [],\n        \"DISULFID\": [],\n        \"HELIX\": [],\n        \"TURN\": [],\n        \"STRAND\": [],\n    }\n\n    def __init__(self, sequence: str) -&gt; None:\n        \"\"\"Instantiates a SiteAnnotations object from a string of amino acid letters.\n\n        It is recommended to call `SiteAnnotations.extract_annotation` after instantiating.\n        Before that, the `SiteAnnotations` object contains only default values.\n\n        Args:\n            sequence (str): A string of amino acid letters. See\n                `type_aliases.AminoAcidLetter` for valid letters.\n        \"\"\"\n        self.residue_letter: list[str] = list(sequence)\n        self.residue_number: list[int] = list(range(1, len(sequence) + 1))\n        self.binding: list[bool] = [False] * len(sequence)\n        self.active: list[bool] = [False] * len(sequence)\n        self.dna_binding: list[bool] = [False] * len(sequence)\n        self.disulfide_bond: list[bool] = [False] * len(sequence)\n        self.helix: list[bool] = [False] * len(sequence)\n        self.turn: list[bool] = [False] * len(sequence)\n        self.beta_strand: list[bool] = [False] * len(sequence)\n\n        self.binding_data: list[dict[str, str]] = [{} for _ in range(len(sequence))]\n        self.active_data: list[dict[str, str]] = [{} for _ in range(len(sequence))]\n\n    def table(self) -&gt; dict[str, list[Any]]:\n        \"\"\"Return a dictionary of the data in the SiteAnnotations object.\n\n        Returns:\n            dict[str, list[Any]]: Each key is a site annotation feature name.\n                Each value is a list of the values for that feature.\n        \"\"\"\n        tbl: dict[str, list[Any]] = {}\n\n        tbl[\"residue_letter\"] = self.residue_letter\n        tbl[\"residue_number\"] = self.residue_number\n        tbl[\"binding\"] = self.binding\n        tbl[\"active\"] = self.active\n        tbl[\"dna_binding\"] = self.dna_binding\n        tbl[\"disulfide_bond\"] = self.disulfide_bond\n        tbl[\"helix\"] = self.helix\n        tbl[\"turn\"] = self.turn\n        tbl[\"beta_strand\"] = self.beta_strand\n        tbl[\"binding_data\"] = self.binding_data\n        tbl[\"active_data\"] = self.active_data\n\n        return tbl\n\n    def __len__(self) -&gt; int:\n        return len(self.residue_letter)\n\n    def _parse_description(\n        self,\n        description_type: str,\n        description: str,\n        extract_metadata: bool | None = None,\n    ) -&gt; tuple[list[bool], list[dict[str, str]] | None]:\n        # example of descrition:\n        # DISULFID 28..87; /evidence=\"ECO:0000255|PROSITE-ProRule:PRU00114\"; DISULFID 105; /note=\"Interchain (with heavy chain)\"\n\n        site_matches = [False] * len(self)\n\n        site_data: list[dict[str, str]] | None = None\n\n        if extract_metadata is None:\n            extract_metadata = bool(self.fields_by_description_type[description_type])\n        if extract_metadata:\n            site_data = [{} for _ in range(len(self))]\n\n        if description_type not in self.fields_by_description_type:\n            raise NotImplementedError(f\"Unknown description type: {description_type}\")\n        if (\n            not description or description != description\n        ):  # not-equal check is for pandas nans\n            return site_matches, site_data\n        if description_type not in description:\n            raise ValueError(\n                f\"{description_type} does not appear in the description: {description}\"\n            )\n\n        stretches = description.split(description_type)\n\n        # first stretch is always empty\n        for stretch in stretches[1:]:\n            fields = stretch.split(\";\")\n            # first field is always site numbers\n            se = fields[0].strip().split(\"..\")\n            start, end = len(self), len(self)\n            if len(se) == 1:\n                start, end = int(se[0]) - 1, int(se[0]) - 1  # uniprot 1-indexes sites\n            elif len(se) == 2:\n                start, end = int(se[0]) - 1, int(se[1]) - 1\n\n            if start &gt;= len(self) or end &gt;= len(self) or start &gt; end:\n                raise ValueError(\n                    f\"Improperly formatted descritpion; site numbers not recognized: {stretch} in {description}\"\n                )\n\n            field_sites = list(range(start, end + 1))\n            for s in field_sites:\n                site_matches[s] = True\n\n            if len(fields) == 1 or site_data is None:\n                continue\n\n            for field in fields[1:]:\n                field = field.strip()\n                for field_id in self.fields_by_description_type[description_type]:\n                    if not field.startswith(f\"/{field_id}=\"):\n                        continue\n                    field_data = field.removeprefix(f\"/{field_id}=\")\n                    for s in field_sites:\n                        if field_id not in site_data[s]:\n                            site_data[s][field_id] = field_data\n                        else:\n                            site_data[s][field_id] += \",\" + field_data\n\n        return site_matches, site_data\n\n    def extract_annotation(\n        self,\n        description_type: str,\n        description: str,\n        extract_metadata: bool | None = None,\n    ) -&gt; None:\n        \"\"\"Extracts the site annotations from the description.\n\n        Args:\n            description_type (str): The type of site annotation to extract. Must be\n                one of the keys in `self.fields_by_description_type`.\n            description (str): The UniProt site description string.\n            extract_metadata (bool | None, optional): Whether to extract metadata.\n                By default, this is inferred from the `description_type` parameter.\n\n        Raises:\n            NotImplementedError: From `_parse_description`. If an unknown `description_type` is provided.\n            ValueError: From `_parse_description`. If the `description_type` is not found in `description`.\n            AssertionError: If a `description_type` is provided that is known to `_parse_description` but\n                not `extract_annotation`. This indicates an internal bug and should be reported.\n        \"\"\"\n        matches, data = self._parse_description(\n            description_type, description, extract_metadata\n        )\n        if description_type == \"ACT_SITE\":\n            self.active = matches\n            if data:\n                self.active_data = data\n        elif description_type == \"BINDING\":\n            self.binding = matches\n            if data:\n                self.binding_data = data\n        elif description_type == \"DNA_BIND\":\n            self.dna_binding = matches\n        elif description_type == \"DISULFID\":\n            self.disulfide_bond = matches\n        elif description_type == \"STRAND\":\n            self.beta_strand = matches\n        elif description_type == \"HELIX\":\n            self.helix = matches\n        elif description_type == \"TURN\":\n            self.turn = matches\n        else:\n            raise AssertionError(\n                f\"If this is raised, the description type {description_type} is only partially handled. Please file an issue.\"\n            )\n</code></pre>"},{"location":"api/#procaliper.site_metadata.SiteAnnotations.__init__","title":"<code>__init__(sequence)</code>","text":"<p>Instantiates a SiteAnnotations object from a string of amino acid letters.</p> <p>It is recommended to call <code>SiteAnnotations.extract_annotation</code> after instantiating. Before that, the <code>SiteAnnotations</code> object contains only default values.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>A string of amino acid letters. See <code>type_aliases.AminoAcidLetter</code> for valid letters.</p> required Source code in <code>procaliper/site_metadata/uniprot_site_parsing.py</code> <pre><code>def __init__(self, sequence: str) -&gt; None:\n    \"\"\"Instantiates a SiteAnnotations object from a string of amino acid letters.\n\n    It is recommended to call `SiteAnnotations.extract_annotation` after instantiating.\n    Before that, the `SiteAnnotations` object contains only default values.\n\n    Args:\n        sequence (str): A string of amino acid letters. See\n            `type_aliases.AminoAcidLetter` for valid letters.\n    \"\"\"\n    self.residue_letter: list[str] = list(sequence)\n    self.residue_number: list[int] = list(range(1, len(sequence) + 1))\n    self.binding: list[bool] = [False] * len(sequence)\n    self.active: list[bool] = [False] * len(sequence)\n    self.dna_binding: list[bool] = [False] * len(sequence)\n    self.disulfide_bond: list[bool] = [False] * len(sequence)\n    self.helix: list[bool] = [False] * len(sequence)\n    self.turn: list[bool] = [False] * len(sequence)\n    self.beta_strand: list[bool] = [False] * len(sequence)\n\n    self.binding_data: list[dict[str, str]] = [{} for _ in range(len(sequence))]\n    self.active_data: list[dict[str, str]] = [{} for _ in range(len(sequence))]\n</code></pre>"},{"location":"api/#procaliper.site_metadata.SiteAnnotations.extract_annotation","title":"<code>extract_annotation(description_type, description, extract_metadata=None)</code>","text":"<p>Extracts the site annotations from the description.</p> <p>Parameters:</p> Name Type Description Default <code>description_type</code> <code>str</code> <p>The type of site annotation to extract. Must be one of the keys in <code>self.fields_by_description_type</code>.</p> required <code>description</code> <code>str</code> <p>The UniProt site description string.</p> required <code>extract_metadata</code> <code>bool | None</code> <p>Whether to extract metadata. By default, this is inferred from the <code>description_type</code> parameter.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>From <code>_parse_description</code>. If an unknown <code>description_type</code> is provided.</p> <code>ValueError</code> <p>From <code>_parse_description</code>. If the <code>description_type</code> is not found in <code>description</code>.</p> <code>AssertionError</code> <p>If a <code>description_type</code> is provided that is known to <code>_parse_description</code> but not <code>extract_annotation</code>. This indicates an internal bug and should be reported.</p> Source code in <code>procaliper/site_metadata/uniprot_site_parsing.py</code> <pre><code>def extract_annotation(\n    self,\n    description_type: str,\n    description: str,\n    extract_metadata: bool | None = None,\n) -&gt; None:\n    \"\"\"Extracts the site annotations from the description.\n\n    Args:\n        description_type (str): The type of site annotation to extract. Must be\n            one of the keys in `self.fields_by_description_type`.\n        description (str): The UniProt site description string.\n        extract_metadata (bool | None, optional): Whether to extract metadata.\n            By default, this is inferred from the `description_type` parameter.\n\n    Raises:\n        NotImplementedError: From `_parse_description`. If an unknown `description_type` is provided.\n        ValueError: From `_parse_description`. If the `description_type` is not found in `description`.\n        AssertionError: If a `description_type` is provided that is known to `_parse_description` but\n            not `extract_annotation`. This indicates an internal bug and should be reported.\n    \"\"\"\n    matches, data = self._parse_description(\n        description_type, description, extract_metadata\n    )\n    if description_type == \"ACT_SITE\":\n        self.active = matches\n        if data:\n            self.active_data = data\n    elif description_type == \"BINDING\":\n        self.binding = matches\n        if data:\n            self.binding_data = data\n    elif description_type == \"DNA_BIND\":\n        self.dna_binding = matches\n    elif description_type == \"DISULFID\":\n        self.disulfide_bond = matches\n    elif description_type == \"STRAND\":\n        self.beta_strand = matches\n    elif description_type == \"HELIX\":\n        self.helix = matches\n    elif description_type == \"TURN\":\n        self.turn = matches\n    else:\n        raise AssertionError(\n            f\"If this is raised, the description type {description_type} is only partially handled. Please file an issue.\"\n        )\n</code></pre>"},{"location":"api/#procaliper.site_metadata.SiteAnnotations.table","title":"<code>table()</code>","text":"<p>Return a dictionary of the data in the SiteAnnotations object.</p> <p>Returns:</p> Type Description <code>dict[str, list[Any]]</code> <p>dict[str, list[Any]]: Each key is a site annotation feature name. Each value is a list of the values for that feature.</p> Source code in <code>procaliper/site_metadata/uniprot_site_parsing.py</code> <pre><code>def table(self) -&gt; dict[str, list[Any]]:\n    \"\"\"Return a dictionary of the data in the SiteAnnotations object.\n\n    Returns:\n        dict[str, list[Any]]: Each key is a site annotation feature name.\n            Each value is a list of the values for that feature.\n    \"\"\"\n    tbl: dict[str, list[Any]] = {}\n\n    tbl[\"residue_letter\"] = self.residue_letter\n    tbl[\"residue_number\"] = self.residue_number\n    tbl[\"binding\"] = self.binding\n    tbl[\"active\"] = self.active\n    tbl[\"dna_binding\"] = self.dna_binding\n    tbl[\"disulfide_bond\"] = self.disulfide_bond\n    tbl[\"helix\"] = self.helix\n    tbl[\"turn\"] = self.turn\n    tbl[\"beta_strand\"] = self.beta_strand\n    tbl[\"binding_data\"] = self.binding_data\n    tbl[\"active_data\"] = self.active_data\n\n    return tbl\n</code></pre>"},{"location":"api/#procaliper.site_metadata.custom_site_data","title":"<code>custom_site_data</code>","text":""},{"location":"api/#procaliper.site_metadata.custom_site_data.CustomSiteData","title":"<code>CustomSiteData</code>","text":"<p>Class for storing custom site-level data.</p> Source code in <code>procaliper/site_metadata/custom_site_data.py</code> <pre><code>class CustomSiteData:\n    \"\"\"Class for storing custom site-level data.\"\"\"\n\n    def __init__(self, residue_number: list[int], data: dict[str, list[Any]]) -&gt; None:\n        self.residue_number = residue_number\n        for key, value in data.items():\n            setattr(self, key, value)\n\n        self.keys = {\"residue_number\"} | set(data.keys())\n\n    @classmethod\n    def from_dict(\n        cls,\n        data: dict[str, list[Any]],\n        residue_index_feature_name: str = \"residue_number\",\n    ) -&gt; CustomSiteData:\n        \"\"\"Create a CustomSiteData object from a dictionary of data.\n\n        Args:\n            data (dict[str, list[Any]]): Data dictionary indexed by feature\n                name. Each value must be a list of the same length as the\n                residue number feature. Must include a residue number key.\n            residue_index_feature_name (str, optional): The name of the feature\n                that contains the residue number. Defaults to \"residue_number\".\n\n        Raises:\n            ValueError: If the residue number feature is not in the data.\n\n        Returns:\n            CustomSiteData: A CustomSiteData object. that contains the data.\n        \"\"\"\n        if residue_index_feature_name not in data:\n            raise ValueError(\"CustomSiteData must have a residue_number key.\")\n        return cls(data[residue_index_feature_name], data)\n\n    def table(self) -&gt; dict[str, list[Any]]:\n        \"\"\"Return a dictionary of the data in the CustomSiteData object.\n\n        Returns:\n            dict[str, list[Any]]: A dictionary of the data in the CustomSiteData\n                object.\n        \"\"\"\n        return {k: getattr(self, k) for k in self.keys}\n\n    def add_residue_numbers(self, residue_number: list[int] | int) -&gt; None:\n        \"\"\"Specify the number of residues in the CustomSiteData object.\n\n        Args:\n            residue_number (list[int] | int): If an integer, the number of\n                residues. If a list of integers, the list of residue numbers.\n        \"\"\"\n        if isinstance(residue_number, int):\n            self.residue_number = list(range(1, residue_number + 1))\n        else:\n            self.residue_number = residue_number\n\n    def add_site_data(self, key: str, row: list[Any], overwrite: bool = False) -&gt; None:\n        \"\"\"Add a site-level feature to the CustomSiteData object.\n\n        Args:\n            key (str): The name of the feature to add.\n            row (list[Any]): The values for the feature.\n\n            overwrite (bool, optional): Whether to overwrite an existing\n                feature. Defaults to False.\n\n        Raises:\n            KeyError: If overwrite is False and the feature already exists.\n            ValueError: If the number of values in the feature does not match\n                the number of residues.\n        \"\"\"\n        if hasattr(self, key) and not overwrite:\n            raise KeyError(\n                f\"CustomSiteData already has a {key} key and overwrite is False.\"\n            )\n\n        if len(row) != len(self.residue_number):\n            raise ValueError(\n                f\"CustomSiteData has {len(self.residue_number)} residues, but {key} has {len(row)} values.\"\n                \" Perhaps you forgot to call add_residue_numbers?\"\n            )\n\n        setattr(self, key, row)\n        self.keys.add(key)\n</code></pre>"},{"location":"api/#procaliper.site_metadata.custom_site_data.CustomSiteData.add_residue_numbers","title":"<code>add_residue_numbers(residue_number)</code>","text":"<p>Specify the number of residues in the CustomSiteData object.</p> <p>Parameters:</p> Name Type Description Default <code>residue_number</code> <code>list[int] | int</code> <p>If an integer, the number of residues. If a list of integers, the list of residue numbers.</p> required Source code in <code>procaliper/site_metadata/custom_site_data.py</code> <pre><code>def add_residue_numbers(self, residue_number: list[int] | int) -&gt; None:\n    \"\"\"Specify the number of residues in the CustomSiteData object.\n\n    Args:\n        residue_number (list[int] | int): If an integer, the number of\n            residues. If a list of integers, the list of residue numbers.\n    \"\"\"\n    if isinstance(residue_number, int):\n        self.residue_number = list(range(1, residue_number + 1))\n    else:\n        self.residue_number = residue_number\n</code></pre>"},{"location":"api/#procaliper.site_metadata.custom_site_data.CustomSiteData.add_site_data","title":"<code>add_site_data(key, row, overwrite=False)</code>","text":"<p>Add a site-level feature to the CustomSiteData object.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the feature to add.</p> required <code>row</code> <code>list[Any]</code> <p>The values for the feature.</p> required <code>overwrite</code> <code>bool</code> <p>Whether to overwrite an existing feature. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If overwrite is False and the feature already exists.</p> <code>ValueError</code> <p>If the number of values in the feature does not match the number of residues.</p> Source code in <code>procaliper/site_metadata/custom_site_data.py</code> <pre><code>def add_site_data(self, key: str, row: list[Any], overwrite: bool = False) -&gt; None:\n    \"\"\"Add a site-level feature to the CustomSiteData object.\n\n    Args:\n        key (str): The name of the feature to add.\n        row (list[Any]): The values for the feature.\n\n        overwrite (bool, optional): Whether to overwrite an existing\n            feature. Defaults to False.\n\n    Raises:\n        KeyError: If overwrite is False and the feature already exists.\n        ValueError: If the number of values in the feature does not match\n            the number of residues.\n    \"\"\"\n    if hasattr(self, key) and not overwrite:\n        raise KeyError(\n            f\"CustomSiteData already has a {key} key and overwrite is False.\"\n        )\n\n    if len(row) != len(self.residue_number):\n        raise ValueError(\n            f\"CustomSiteData has {len(self.residue_number)} residues, but {key} has {len(row)} values.\"\n            \" Perhaps you forgot to call add_residue_numbers?\"\n        )\n\n    setattr(self, key, row)\n    self.keys.add(key)\n</code></pre>"},{"location":"api/#procaliper.site_metadata.custom_site_data.CustomSiteData.from_dict","title":"<code>from_dict(data, residue_index_feature_name='residue_number')</code>  <code>classmethod</code>","text":"<p>Create a CustomSiteData object from a dictionary of data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, list[Any]]</code> <p>Data dictionary indexed by feature name. Each value must be a list of the same length as the residue number feature. Must include a residue number key.</p> required <code>residue_index_feature_name</code> <code>str</code> <p>The name of the feature that contains the residue number. Defaults to \"residue_number\".</p> <code>'residue_number'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the residue number feature is not in the data.</p> <p>Returns:</p> Name Type Description <code>CustomSiteData</code> <code>CustomSiteData</code> <p>A CustomSiteData object. that contains the data.</p> Source code in <code>procaliper/site_metadata/custom_site_data.py</code> <pre><code>@classmethod\ndef from_dict(\n    cls,\n    data: dict[str, list[Any]],\n    residue_index_feature_name: str = \"residue_number\",\n) -&gt; CustomSiteData:\n    \"\"\"Create a CustomSiteData object from a dictionary of data.\n\n    Args:\n        data (dict[str, list[Any]]): Data dictionary indexed by feature\n            name. Each value must be a list of the same length as the\n            residue number feature. Must include a residue number key.\n        residue_index_feature_name (str, optional): The name of the feature\n            that contains the residue number. Defaults to \"residue_number\".\n\n    Raises:\n        ValueError: If the residue number feature is not in the data.\n\n    Returns:\n        CustomSiteData: A CustomSiteData object. that contains the data.\n    \"\"\"\n    if residue_index_feature_name not in data:\n        raise ValueError(\"CustomSiteData must have a residue_number key.\")\n    return cls(data[residue_index_feature_name], data)\n</code></pre>"},{"location":"api/#procaliper.site_metadata.custom_site_data.CustomSiteData.table","title":"<code>table()</code>","text":"<p>Return a dictionary of the data in the CustomSiteData object.</p> <p>Returns:</p> Type Description <code>dict[str, list[Any]]</code> <p>dict[str, list[Any]]: A dictionary of the data in the CustomSiteData object.</p> Source code in <code>procaliper/site_metadata/custom_site_data.py</code> <pre><code>def table(self) -&gt; dict[str, list[Any]]:\n    \"\"\"Return a dictionary of the data in the CustomSiteData object.\n\n    Returns:\n        dict[str, list[Any]]: A dictionary of the data in the CustomSiteData\n            object.\n    \"\"\"\n    return {k: getattr(self, k) for k in self.keys}\n</code></pre>"},{"location":"api/#procaliper.site_metadata.uniprot_site_parsing","title":"<code>uniprot_site_parsing</code>","text":""},{"location":"api/#procaliper.site_metadata.uniprot_site_parsing.SiteAnnotations","title":"<code>SiteAnnotations</code>","text":"<p>Class for parsing and storing UniProt site annotations.</p> <p>An example of a UniProt site annotation:</p> <p><code>DISULFID 28..87; /evidence=\"ECO:0000255|PROSITE-ProRule:PRU00114\"; DISULFID 105; /note=\"Interchain (with heavy chain)\"</code></p> <p>Attributes:</p> Name Type Description <code>residue_letter</code> <code>list[str]</code> <p>A list of amino acid letters.</p> <code>residue_number</code> <code>list[int]</code> <p>A list of residue numbers.</p> <code>binding</code> <code>list[bool]</code> <p>A list of booleans indicating whether a residue is a binding site.</p> <code>active</code> <code>list[bool]</code> <p>A list of booleans indicating whether a residue is an active site.</p> <code>dna_binding</code> <code>list[bool]</code> <p>A list of booleans indicating whether a residue is a DNA binding site.</p> <code>disulfide_bond</code> <code>list[bool]</code> <p>A list of booleans indicating whether a residue is a disulfide bond.</p> <code>helix</code> <code>list[bool]</code> <p>A list of booleans indicating whether a residue is in a helix.</p> <code>turn</code> <code>list[bool]</code> <p>A list of booleans indicating whether a residue is in a turn.</p> <code>beta_strand</code> <code>list[bool]</code> <p>A list of booleans indicating whether a residue is in a beta strand.</p> <code>binding_data</code> <code>list[dict[str, str]]</code> <p>A list of dictionaries containing binding site metadata.</p> <code>active_data</code> <code>list[dict[str, str]]</code> <p>A list of dictionaries containing active site metadata.</p> Source code in <code>procaliper/site_metadata/uniprot_site_parsing.py</code> <pre><code>class SiteAnnotations:\n    \"\"\"Class for parsing and storing UniProt site annotations.\n\n    An example of a UniProt site annotation:\n\n    `DISULFID 28..87; /evidence=\"ECO:0000255|PROSITE-ProRule:PRU00114\"; DISULFID 105; /note=\"Interchain (with heavy chain)\"`\n\n    Attributes:\n        residue_letter (list[str]): A list of amino acid letters.\n        residue_number (list[int]): A list of residue numbers.\n        binding (list[bool]): A list of booleans indicating whether a residue\n            is a binding site.\n        active (list[bool]): A list of booleans indicating whether a residue\n            is an active site.\n        dna_binding (list[bool]): A list of booleans indicating whether a residue\n            is a DNA binding site.\n        disulfide_bond (list[bool]): A list of booleans indicating whether a residue\n            is a disulfide bond.\n        helix (list[bool]): A list of booleans indicating whether a residue\n            is in a helix.\n        turn (list[bool]): A list of booleans indicating whether a residue\n            is in a turn.\n        beta_strand (list[bool]): A list of booleans indicating whether a residue\n            is in a beta strand.\n        binding_data (list[dict[str, str]]): A list of dictionaries containing\n            binding site metadata.\n        active_data (list[dict[str, str]]): A list of dictionaries containing\n            active site metadata.\n    \"\"\"\n\n    fields_by_description_type = {\n        \"BINDING\": [\"ligand\"],\n        \"ACT_SITE\": [\"note\"],\n        \"DNA_BIND\": [],\n        \"DISULFID\": [],\n        \"HELIX\": [],\n        \"TURN\": [],\n        \"STRAND\": [],\n    }\n\n    def __init__(self, sequence: str) -&gt; None:\n        \"\"\"Instantiates a SiteAnnotations object from a string of amino acid letters.\n\n        It is recommended to call `SiteAnnotations.extract_annotation` after instantiating.\n        Before that, the `SiteAnnotations` object contains only default values.\n\n        Args:\n            sequence (str): A string of amino acid letters. See\n                `type_aliases.AminoAcidLetter` for valid letters.\n        \"\"\"\n        self.residue_letter: list[str] = list(sequence)\n        self.residue_number: list[int] = list(range(1, len(sequence) + 1))\n        self.binding: list[bool] = [False] * len(sequence)\n        self.active: list[bool] = [False] * len(sequence)\n        self.dna_binding: list[bool] = [False] * len(sequence)\n        self.disulfide_bond: list[bool] = [False] * len(sequence)\n        self.helix: list[bool] = [False] * len(sequence)\n        self.turn: list[bool] = [False] * len(sequence)\n        self.beta_strand: list[bool] = [False] * len(sequence)\n\n        self.binding_data: list[dict[str, str]] = [{} for _ in range(len(sequence))]\n        self.active_data: list[dict[str, str]] = [{} for _ in range(len(sequence))]\n\n    def table(self) -&gt; dict[str, list[Any]]:\n        \"\"\"Return a dictionary of the data in the SiteAnnotations object.\n\n        Returns:\n            dict[str, list[Any]]: Each key is a site annotation feature name.\n                Each value is a list of the values for that feature.\n        \"\"\"\n        tbl: dict[str, list[Any]] = {}\n\n        tbl[\"residue_letter\"] = self.residue_letter\n        tbl[\"residue_number\"] = self.residue_number\n        tbl[\"binding\"] = self.binding\n        tbl[\"active\"] = self.active\n        tbl[\"dna_binding\"] = self.dna_binding\n        tbl[\"disulfide_bond\"] = self.disulfide_bond\n        tbl[\"helix\"] = self.helix\n        tbl[\"turn\"] = self.turn\n        tbl[\"beta_strand\"] = self.beta_strand\n        tbl[\"binding_data\"] = self.binding_data\n        tbl[\"active_data\"] = self.active_data\n\n        return tbl\n\n    def __len__(self) -&gt; int:\n        return len(self.residue_letter)\n\n    def _parse_description(\n        self,\n        description_type: str,\n        description: str,\n        extract_metadata: bool | None = None,\n    ) -&gt; tuple[list[bool], list[dict[str, str]] | None]:\n        # example of descrition:\n        # DISULFID 28..87; /evidence=\"ECO:0000255|PROSITE-ProRule:PRU00114\"; DISULFID 105; /note=\"Interchain (with heavy chain)\"\n\n        site_matches = [False] * len(self)\n\n        site_data: list[dict[str, str]] | None = None\n\n        if extract_metadata is None:\n            extract_metadata = bool(self.fields_by_description_type[description_type])\n        if extract_metadata:\n            site_data = [{} for _ in range(len(self))]\n\n        if description_type not in self.fields_by_description_type:\n            raise NotImplementedError(f\"Unknown description type: {description_type}\")\n        if (\n            not description or description != description\n        ):  # not-equal check is for pandas nans\n            return site_matches, site_data\n        if description_type not in description:\n            raise ValueError(\n                f\"{description_type} does not appear in the description: {description}\"\n            )\n\n        stretches = description.split(description_type)\n\n        # first stretch is always empty\n        for stretch in stretches[1:]:\n            fields = stretch.split(\";\")\n            # first field is always site numbers\n            se = fields[0].strip().split(\"..\")\n            start, end = len(self), len(self)\n            if len(se) == 1:\n                start, end = int(se[0]) - 1, int(se[0]) - 1  # uniprot 1-indexes sites\n            elif len(se) == 2:\n                start, end = int(se[0]) - 1, int(se[1]) - 1\n\n            if start &gt;= len(self) or end &gt;= len(self) or start &gt; end:\n                raise ValueError(\n                    f\"Improperly formatted descritpion; site numbers not recognized: {stretch} in {description}\"\n                )\n\n            field_sites = list(range(start, end + 1))\n            for s in field_sites:\n                site_matches[s] = True\n\n            if len(fields) == 1 or site_data is None:\n                continue\n\n            for field in fields[1:]:\n                field = field.strip()\n                for field_id in self.fields_by_description_type[description_type]:\n                    if not field.startswith(f\"/{field_id}=\"):\n                        continue\n                    field_data = field.removeprefix(f\"/{field_id}=\")\n                    for s in field_sites:\n                        if field_id not in site_data[s]:\n                            site_data[s][field_id] = field_data\n                        else:\n                            site_data[s][field_id] += \",\" + field_data\n\n        return site_matches, site_data\n\n    def extract_annotation(\n        self,\n        description_type: str,\n        description: str,\n        extract_metadata: bool | None = None,\n    ) -&gt; None:\n        \"\"\"Extracts the site annotations from the description.\n\n        Args:\n            description_type (str): The type of site annotation to extract. Must be\n                one of the keys in `self.fields_by_description_type`.\n            description (str): The UniProt site description string.\n            extract_metadata (bool | None, optional): Whether to extract metadata.\n                By default, this is inferred from the `description_type` parameter.\n\n        Raises:\n            NotImplementedError: From `_parse_description`. If an unknown `description_type` is provided.\n            ValueError: From `_parse_description`. If the `description_type` is not found in `description`.\n            AssertionError: If a `description_type` is provided that is known to `_parse_description` but\n                not `extract_annotation`. This indicates an internal bug and should be reported.\n        \"\"\"\n        matches, data = self._parse_description(\n            description_type, description, extract_metadata\n        )\n        if description_type == \"ACT_SITE\":\n            self.active = matches\n            if data:\n                self.active_data = data\n        elif description_type == \"BINDING\":\n            self.binding = matches\n            if data:\n                self.binding_data = data\n        elif description_type == \"DNA_BIND\":\n            self.dna_binding = matches\n        elif description_type == \"DISULFID\":\n            self.disulfide_bond = matches\n        elif description_type == \"STRAND\":\n            self.beta_strand = matches\n        elif description_type == \"HELIX\":\n            self.helix = matches\n        elif description_type == \"TURN\":\n            self.turn = matches\n        else:\n            raise AssertionError(\n                f\"If this is raised, the description type {description_type} is only partially handled. Please file an issue.\"\n            )\n</code></pre>"},{"location":"api/#procaliper.site_metadata.uniprot_site_parsing.SiteAnnotations.__init__","title":"<code>__init__(sequence)</code>","text":"<p>Instantiates a SiteAnnotations object from a string of amino acid letters.</p> <p>It is recommended to call <code>SiteAnnotations.extract_annotation</code> after instantiating. Before that, the <code>SiteAnnotations</code> object contains only default values.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>A string of amino acid letters. See <code>type_aliases.AminoAcidLetter</code> for valid letters.</p> required Source code in <code>procaliper/site_metadata/uniprot_site_parsing.py</code> <pre><code>def __init__(self, sequence: str) -&gt; None:\n    \"\"\"Instantiates a SiteAnnotations object from a string of amino acid letters.\n\n    It is recommended to call `SiteAnnotations.extract_annotation` after instantiating.\n    Before that, the `SiteAnnotations` object contains only default values.\n\n    Args:\n        sequence (str): A string of amino acid letters. See\n            `type_aliases.AminoAcidLetter` for valid letters.\n    \"\"\"\n    self.residue_letter: list[str] = list(sequence)\n    self.residue_number: list[int] = list(range(1, len(sequence) + 1))\n    self.binding: list[bool] = [False] * len(sequence)\n    self.active: list[bool] = [False] * len(sequence)\n    self.dna_binding: list[bool] = [False] * len(sequence)\n    self.disulfide_bond: list[bool] = [False] * len(sequence)\n    self.helix: list[bool] = [False] * len(sequence)\n    self.turn: list[bool] = [False] * len(sequence)\n    self.beta_strand: list[bool] = [False] * len(sequence)\n\n    self.binding_data: list[dict[str, str]] = [{} for _ in range(len(sequence))]\n    self.active_data: list[dict[str, str]] = [{} for _ in range(len(sequence))]\n</code></pre>"},{"location":"api/#procaliper.site_metadata.uniprot_site_parsing.SiteAnnotations.extract_annotation","title":"<code>extract_annotation(description_type, description, extract_metadata=None)</code>","text":"<p>Extracts the site annotations from the description.</p> <p>Parameters:</p> Name Type Description Default <code>description_type</code> <code>str</code> <p>The type of site annotation to extract. Must be one of the keys in <code>self.fields_by_description_type</code>.</p> required <code>description</code> <code>str</code> <p>The UniProt site description string.</p> required <code>extract_metadata</code> <code>bool | None</code> <p>Whether to extract metadata. By default, this is inferred from the <code>description_type</code> parameter.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>From <code>_parse_description</code>. If an unknown <code>description_type</code> is provided.</p> <code>ValueError</code> <p>From <code>_parse_description</code>. If the <code>description_type</code> is not found in <code>description</code>.</p> <code>AssertionError</code> <p>If a <code>description_type</code> is provided that is known to <code>_parse_description</code> but not <code>extract_annotation</code>. This indicates an internal bug and should be reported.</p> Source code in <code>procaliper/site_metadata/uniprot_site_parsing.py</code> <pre><code>def extract_annotation(\n    self,\n    description_type: str,\n    description: str,\n    extract_metadata: bool | None = None,\n) -&gt; None:\n    \"\"\"Extracts the site annotations from the description.\n\n    Args:\n        description_type (str): The type of site annotation to extract. Must be\n            one of the keys in `self.fields_by_description_type`.\n        description (str): The UniProt site description string.\n        extract_metadata (bool | None, optional): Whether to extract metadata.\n            By default, this is inferred from the `description_type` parameter.\n\n    Raises:\n        NotImplementedError: From `_parse_description`. If an unknown `description_type` is provided.\n        ValueError: From `_parse_description`. If the `description_type` is not found in `description`.\n        AssertionError: If a `description_type` is provided that is known to `_parse_description` but\n            not `extract_annotation`. This indicates an internal bug and should be reported.\n    \"\"\"\n    matches, data = self._parse_description(\n        description_type, description, extract_metadata\n    )\n    if description_type == \"ACT_SITE\":\n        self.active = matches\n        if data:\n            self.active_data = data\n    elif description_type == \"BINDING\":\n        self.binding = matches\n        if data:\n            self.binding_data = data\n    elif description_type == \"DNA_BIND\":\n        self.dna_binding = matches\n    elif description_type == \"DISULFID\":\n        self.disulfide_bond = matches\n    elif description_type == \"STRAND\":\n        self.beta_strand = matches\n    elif description_type == \"HELIX\":\n        self.helix = matches\n    elif description_type == \"TURN\":\n        self.turn = matches\n    else:\n        raise AssertionError(\n            f\"If this is raised, the description type {description_type} is only partially handled. Please file an issue.\"\n        )\n</code></pre>"},{"location":"api/#procaliper.site_metadata.uniprot_site_parsing.SiteAnnotations.table","title":"<code>table()</code>","text":"<p>Return a dictionary of the data in the SiteAnnotations object.</p> <p>Returns:</p> Type Description <code>dict[str, list[Any]]</code> <p>dict[str, list[Any]]: Each key is a site annotation feature name. Each value is a list of the values for that feature.</p> Source code in <code>procaliper/site_metadata/uniprot_site_parsing.py</code> <pre><code>def table(self) -&gt; dict[str, list[Any]]:\n    \"\"\"Return a dictionary of the data in the SiteAnnotations object.\n\n    Returns:\n        dict[str, list[Any]]: Each key is a site annotation feature name.\n            Each value is a list of the values for that feature.\n    \"\"\"\n    tbl: dict[str, list[Any]] = {}\n\n    tbl[\"residue_letter\"] = self.residue_letter\n    tbl[\"residue_number\"] = self.residue_number\n    tbl[\"binding\"] = self.binding\n    tbl[\"active\"] = self.active\n    tbl[\"dna_binding\"] = self.dna_binding\n    tbl[\"disulfide_bond\"] = self.disulfide_bond\n    tbl[\"helix\"] = self.helix\n    tbl[\"turn\"] = self.turn\n    tbl[\"beta_strand\"] = self.beta_strand\n    tbl[\"binding_data\"] = self.binding_data\n    tbl[\"active_data\"] = self.active_data\n\n    return tbl\n</code></pre>"},{"location":"api/#procaliper.view","title":"<code>view</code>","text":""},{"location":"api/#procaliper.view.ngl_scheme","title":"<code>ngl_scheme(data, float_to_hex=None, two_sided=False)</code>","text":"<p>Converts a list of values to an nglview color scheme.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[float]</code> <p>The list of values to convert.</p> required <code>float_to_hex</code> <code>Callable[[float], str] | None</code> <p>Function that converts a float to a hex color in the form <code>\"#RRGGBB\"</code>. If <code>None</code>, a default function is used that interpolates between white and green (one-sided) or red and blue (two-sided). Defaults to <code>None</code>.</p> <code>None</code> <code>two_sided</code> <code>bool</code> <p>Whether to use a two-sided color scheme. If <code>False</code>, we assume <code>data</code> only contains positive values. Defaults to <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>list[tuple[str, str]]: A list of color and residue number tuples that are compatible with nglview.</p> Source code in <code>procaliper/view/nglview_utils.py</code> <pre><code>def ngl_scheme(\n    data: list[float],\n    float_to_hex: Callable[[float], str] | None = None,\n    two_sided: bool = False,\n) -&gt; list[tuple[str, str]]:\n    \"\"\"Converts a list of values to an nglview color scheme.\n\n    Args:\n        data (list[float]): The list of values to convert.\n        float_to_hex (Callable[[float], str] | None, optional): Function that\n            converts a float to a hex color in the form `\"#RRGGBB\"`. If `None`,\n            a default function is used that interpolates between white and green\n            (one-sided) or red and blue (two-sided). Defaults to `None`.\n        two_sided (bool, optional): Whether to use a two-sided color scheme. If\n            `False`, we assume `data` only contains positive values. Defaults to\n            `False`.\n\n    Returns:\n        list[tuple[str, str]]: A list of color and residue number tuples that\n            are compatible with nglview.\n    \"\"\"\n    if float_to_hex is None:\n        if two_sided:\n            float_to_hex = _default_float_to_hex_rb\n        else:\n            float_to_hex = _default_float_to_hex\n\n    maxx = max(data)\n    scale = max(min(data), abs(maxx)) if two_sided else maxx\n\n    if scale == 0:\n        data_scaled = [0.0] * len(data)\n    else:\n        data_scaled = [x / maxx for x in data]\n\n    return [(float_to_hex(x), f\"{i+1}\") for i, x in enumerate(data_scaled)]\n</code></pre>"},{"location":"api/#procaliper.view.protein_to_nglview","title":"<code>protein_to_nglview(protein)</code>","text":"<p>Generates an nglview widget from a protein that has an associated PDB file.</p> <p>Must run <code>protein.fetch_pdb</code> first or specify an abosulute path to the PDB in <code>protein.pdb_location_absolute</code>.</p> <p>Parameters:</p> Name Type Description Default <code>protein</code> <code>Protein</code> <p>The protein object to visualize.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the PDB location is not set.</p> <p>Returns:</p> Type Description <code>NGLWidget</code> <p>nglview.NGLWidget: an nglview widget</p> Source code in <code>procaliper/view/nglview_utils.py</code> <pre><code>def protein_to_nglview(protein: Protein) -&gt; nglview.NGLWidget:\n    \"\"\"Generates an nglview widget from a protein that has an associated PDB file.\n\n    Must run `protein.fetch_pdb` first or specify an abosulute path to the PDB\n    in `protein.pdb_location_absolute`.\n\n    Args:\n        protein (Protein): The protein object to visualize.\n\n    Raises:\n        ValueError: If the PDB location is not set.\n\n    Returns:\n        nglview.NGLWidget: an nglview widget\n    \"\"\"\n    if not protein.pdb_location_absolute:\n        raise ValueError(\"PDB location not set; use `fetch_pdb` first\")\n    return nglview.show_file(protein.pdb_location_absolute)\n</code></pre>"},{"location":"api/#procaliper.view.nglview_utils","title":"<code>nglview_utils</code>","text":""},{"location":"api/#procaliper.view.nglview_utils.ngl_scheme","title":"<code>ngl_scheme(data, float_to_hex=None, two_sided=False)</code>","text":"<p>Converts a list of values to an nglview color scheme.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[float]</code> <p>The list of values to convert.</p> required <code>float_to_hex</code> <code>Callable[[float], str] | None</code> <p>Function that converts a float to a hex color in the form <code>\"#RRGGBB\"</code>. If <code>None</code>, a default function is used that interpolates between white and green (one-sided) or red and blue (two-sided). Defaults to <code>None</code>.</p> <code>None</code> <code>two_sided</code> <code>bool</code> <p>Whether to use a two-sided color scheme. If <code>False</code>, we assume <code>data</code> only contains positive values. Defaults to <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>list[tuple[str, str]]: A list of color and residue number tuples that are compatible with nglview.</p> Source code in <code>procaliper/view/nglview_utils.py</code> <pre><code>def ngl_scheme(\n    data: list[float],\n    float_to_hex: Callable[[float], str] | None = None,\n    two_sided: bool = False,\n) -&gt; list[tuple[str, str]]:\n    \"\"\"Converts a list of values to an nglview color scheme.\n\n    Args:\n        data (list[float]): The list of values to convert.\n        float_to_hex (Callable[[float], str] | None, optional): Function that\n            converts a float to a hex color in the form `\"#RRGGBB\"`. If `None`,\n            a default function is used that interpolates between white and green\n            (one-sided) or red and blue (two-sided). Defaults to `None`.\n        two_sided (bool, optional): Whether to use a two-sided color scheme. If\n            `False`, we assume `data` only contains positive values. Defaults to\n            `False`.\n\n    Returns:\n        list[tuple[str, str]]: A list of color and residue number tuples that\n            are compatible with nglview.\n    \"\"\"\n    if float_to_hex is None:\n        if two_sided:\n            float_to_hex = _default_float_to_hex_rb\n        else:\n            float_to_hex = _default_float_to_hex\n\n    maxx = max(data)\n    scale = max(min(data), abs(maxx)) if two_sided else maxx\n\n    if scale == 0:\n        data_scaled = [0.0] * len(data)\n    else:\n        data_scaled = [x / maxx for x in data]\n\n    return [(float_to_hex(x), f\"{i+1}\") for i, x in enumerate(data_scaled)]\n</code></pre>"},{"location":"api/#procaliper.view.nglview_utils.protein_to_nglview","title":"<code>protein_to_nglview(protein)</code>","text":"<p>Generates an nglview widget from a protein that has an associated PDB file.</p> <p>Must run <code>protein.fetch_pdb</code> first or specify an abosulute path to the PDB in <code>protein.pdb_location_absolute</code>.</p> <p>Parameters:</p> Name Type Description Default <code>protein</code> <code>Protein</code> <p>The protein object to visualize.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the PDB location is not set.</p> <p>Returns:</p> Type Description <code>NGLWidget</code> <p>nglview.NGLWidget: an nglview widget</p> Source code in <code>procaliper/view/nglview_utils.py</code> <pre><code>def protein_to_nglview(protein: Protein) -&gt; nglview.NGLWidget:\n    \"\"\"Generates an nglview widget from a protein that has an associated PDB file.\n\n    Must run `protein.fetch_pdb` first or specify an abosulute path to the PDB\n    in `protein.pdb_location_absolute`.\n\n    Args:\n        protein (Protein): The protein object to visualize.\n\n    Raises:\n        ValueError: If the PDB location is not set.\n\n    Returns:\n        nglview.NGLWidget: an nglview widget\n    \"\"\"\n    if not protein.pdb_location_absolute:\n        raise ValueError(\"PDB location not set; use `fetch_pdb` first\")\n    return nglview.show_file(protein.pdb_location_absolute)\n</code></pre>"},{"location":"authors/","title":"authors","text":""},{"location":"authors/#credits","title":"Credits","text":"<ul> <li>Song Feng song.feng@pnnl.gov</li> <li>Ally Im alexandria.im@pnnl.gov</li> <li>Doo Nam Kim doonam.kim@pnnl.gov</li> <li>Jordan Rozum jordan.rozum@pnnl.gov</li> <li>Hunter Ufford hunter.ufford@pnnl.gov</li> </ul>"},{"location":"contributing/","title":"contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/PhenoMeters/procaliper/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>procaliper could always use more documentation, whether as part of the official procaliper docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/PhenoMeters/procaliper/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>procaliper</code> for local development.</p> <ol> <li>Fork the <code>procaliper</code> repo on GitHub.</li> <li>Clone your fork locally</li> </ol> <pre><code>    $ git clone git@github.com:your_name_here/procaliper.git\n</code></pre> <ol> <li>Ensure poetry is installed.</li> <li>Install dependencies and start your virtualenv:</li> </ol> <p><pre><code>    $ poetry install -E \"test doc dev\"\n</code></pre> The above command will install the optional dependencies needed for developement. See <code>pyproject.toml</code> for additional features to install.</p> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>    $ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</li> </ol> <pre><code>    $ poetry run tox\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>    $ git add .\n    $ git commit -m \"Your detailed description of your changes.\"\n    $ git push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python &gt;=3.9. Check    https://github.com/PhenoMeters/procaliper/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips","text":"<p>To run a specific test: <pre><code>    $ poetry run python -m pytest .\\tests\\test_site_annotation.py -k \"test_site_annotations_with_data\"\n</code></pre></p>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run:</p> <pre><code>$ poetry patch # possible: major / minor / patch\n$ git push\n$ git push --tags\n</code></pre> <p>Github Actions will then deploy to PyPI if tests pass.</p>"},{"location":"history/","title":"history","text":""},{"location":"history/#history","title":"History","text":""},{"location":"history/#010-2024-01-08","title":"0.1.0 (2024-01-08)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"installation/","title":"installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install procaliper, run this command in your terminal:</p> <pre><code>pip install procaliper\n</code></pre> <p>This is the preferred method to install procaliper, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for procaliper can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>git clone git://github.com/LifeWorks/procaliper\n</code></pre> <p>Or download the tarball:</p> <pre><code>curl -OJL https://github.com/LifeWorks/procaliper/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>pip install .\n</code></pre>"},{"location":"usage/","title":"usage","text":""},{"location":"usage/#usage","title":"Usage","text":"<p>To use procaliper in a project</p> <pre><code>    import procaliper\n</code></pre>"}]}